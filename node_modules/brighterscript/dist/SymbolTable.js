"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SymbolTable = void 0;
/**
 * Stores the types associated with variables and functions in the Brighterscript code
 * Can be part of a hierarchy, so lookups can reference parent scopes
 */
class SymbolTable {
    constructor(parent) {
        /**
         * The map of symbols declared directly in this SymbolTable (excludes parent SymbolTable).
         * Indexed by lower symbol name
         */
        this.symbolMap = new Map();
        /**
         * Sets the parent table for lookups. There can only be one parent at a time, but sometimes you
         * want to temporarily change the parent, and then restore it later. This allows that.
         *
         * @param [parent]
         */
        this.parentStack = [];
        this.pushParent(parent);
    }
    get parent() {
        return this.parentStack[0];
    }
    pushParent(parent) {
        this.parentStack.unshift(parent);
        return parent;
    }
    /**
     * Remove the current parent, restoring the previous parent (if there was one)
     */
    popParent() {
        return this.parentStack.shift();
    }
    /**
     * Checks if the symbol table contains the given symbol by name
     * If the identifier is not in this table, it will check the parent
     *
     * @param name the name to lookup
     * @param searchParent should we look to our parent if we don't have the symbol?
     * @returns true if this symbol is in the symbol table
     */
    hasSymbol(name, searchParent = true) {
        var _a;
        const key = name.toLowerCase();
        let result = this.symbolMap.has(key);
        if (!result && searchParent) {
            result = !!((_a = this.parent) === null || _a === void 0 ? void 0 : _a.hasSymbol(key));
        }
        return result;
    }
    /**
     * Gets the name/type pair for a given named variable or function name
     * If the identifier is not in this table, it will check the parent
     *
     * @param  name the name to lookup
     * @param searchParent should we look to our parent if we don't have the symbol?
     * @returns An array of BscSymbols - one for each time this symbol had a type implicitly defined
     */
    getSymbol(name, searchParent = true) {
        var _a;
        const key = name.toLowerCase();
        let result = this.symbolMap.get(key);
        if (!result && searchParent) {
            result = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getSymbol(key);
        }
        return result;
    }
    /**
     * Adds a new symbol to the table
     * @param name
     * @param  type
     */
    addSymbol(name, range, type) {
        const key = name.toLowerCase();
        if (!this.symbolMap.has(key)) {
            this.symbolMap.set(key, []);
        }
        this.symbolMap.get(key).push({
            name: name,
            range: range,
            type: type
        });
    }
    /**
     * Adds all the symbols from another table to this one
     * It will overwrite any existing symbols in this table
     * @param symbolTable
     */
    mergeSymbolTable(symbolTable) {
        for (let [, value] of symbolTable.symbolMap) {
            for (const symbol of value) {
                this.addSymbol(symbol.name, symbol.range, symbol.type);
            }
        }
    }
    /**
     * Serialize this SymbolTable to JSON (useful for debugging reasons)
     */
    toJSON() {
        var _a;
        return {
            parent: (_a = this.parent) === null || _a === void 0 ? void 0 : _a.toJSON(),
            symbols: [
                ...new Set([...this.symbolMap.entries()].map(([key, symbols]) => {
                    return symbols.map(x => x.name);
                }).flat().sort())
            ]
        };
    }
}
exports.SymbolTable = SymbolTable;
//# sourceMappingURL=SymbolTable.js.map