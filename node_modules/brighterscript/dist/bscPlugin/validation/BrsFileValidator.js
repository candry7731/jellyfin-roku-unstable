"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrsFileValidator = void 0;
const reflection_1 = require("../../astUtils/reflection");
const visitors_1 = require("../../astUtils/visitors");
const DiagnosticMessages_1 = require("../../DiagnosticMessages");
const TokenKind_1 = require("../../lexer/TokenKind");
class BrsFileValidator {
    constructor(event) {
        this.event = event;
    }
    process() {
        this.walk();
        this.flagTopLevelStatements();
    }
    /**
     * Set the parent node on a given AstNode. This handles some edge cases where not every expression is iterated normally,
     * so it will also reach into nested objects to set their parent values as well
     */
    setParent(node1, parent) {
        const pairs = [[node1, parent]];
        while (pairs.length > 0) {
            const [childNode, parentNode] = pairs.pop();
            //skip this entry if there's already a parent
            if (childNode === null || childNode === void 0 ? void 0 : childNode.parent) {
                continue;
            }
            if ((0, reflection_1.isDottedGetExpression)(childNode)) {
                if (!childNode.obj.parent) {
                    pairs.push([childNode.obj, childNode]);
                }
            }
            else if ((0, reflection_1.isNamespaceStatement)(childNode)) {
                //namespace names shouldn't be walked, but it needs its parent assigned
                pairs.push([childNode.nameExpression, childNode]);
            }
            else if ((0, reflection_1.isClassStatement)(childNode)) {
                //class extends names don't get walked, but it needs its parent
                if (childNode.parentClassName) {
                    pairs.push([childNode.parentClassName, childNode]);
                }
            }
            else if ((0, reflection_1.isInterfaceStatement)(childNode)) {
                //class extends names don't get walked, but it needs its parent
                if (childNode.parentInterfaceName) {
                    pairs.push([childNode.parentInterfaceName, childNode]);
                }
            }
            else if ((0, reflection_1.isNamespacedVariableNameExpression)(childNode)) {
                pairs.push([childNode.expression, childNode]);
            }
            childNode.parent = parentNode;
        }
    }
    /**
     * Walk the full AST
     */
    walk() {
        this.event.file.ast.walk((node, parent) => {
            // link every child with its parent
            this.setParent(node, parent);
            //do some file-based validations
            if ((0, reflection_1.isEnumStatement)(node)) {
                this.validateEnumDeclaration(node);
            }
        }, {
            walkMode: visitors_1.WalkMode.visitAllRecursive
        });
    }
    validateEnumDeclaration(stmt) {
        var _a, _b, _c, _d, _e;
        const members = stmt.getMembers();
        //the enum data type is based on the first member value
        const enumValueKind = (_d = (_c = (_b = (_a = members.find(x => x.value)) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.token) === null || _c === void 0 ? void 0 : _c.kind) !== null && _d !== void 0 ? _d : TokenKind_1.TokenKind.IntegerLiteral;
        const memberNames = new Set();
        for (const member of members) {
            const memberNameLower = (_e = member.name) === null || _e === void 0 ? void 0 : _e.toLowerCase();
            /**
             * flag duplicate member names
             */
            if (memberNames.has(memberNameLower)) {
                this.event.file.addDiagnostic(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.duplicateIdentifier(member.name)), { range: member.range }));
            }
            else {
                memberNames.add(memberNameLower);
            }
            //Enforce all member values are the same type
            this.validateEnumValueTypes(member, enumValueKind);
        }
    }
    validateEnumValueTypes(member, enumValueKind) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const memberValueKind = (_b = (_a = member.value) === null || _a === void 0 ? void 0 : _a.token) === null || _b === void 0 ? void 0 : _b.kind;
        if (
        //is integer enum, has value, that value type is not integer
        (enumValueKind === TokenKind_1.TokenKind.IntegerLiteral && memberValueKind && memberValueKind !== enumValueKind) ||
            //has value, that value is not a literal
            (member.value && !(0, reflection_1.isLiteralExpression)(member.value))) {
            this.event.file.addDiagnostic(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.enumValueMustBeType(enumValueKind.replace(/literal$/i, '').toLowerCase())), { range: (_d = ((_c = member.value) !== null && _c !== void 0 ? _c : member)) === null || _d === void 0 ? void 0 : _d.range }));
        }
        //is non integer value
        if (enumValueKind !== TokenKind_1.TokenKind.IntegerLiteral) {
            //default value present
            if (memberValueKind) {
                //member value is same as enum
                if (memberValueKind !== enumValueKind) {
                    this.event.file.addDiagnostic(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.enumValueMustBeType(enumValueKind.replace(/literal$/i, '').toLowerCase())), { range: (_f = ((_e = member.value) !== null && _e !== void 0 ? _e : member)) === null || _f === void 0 ? void 0 : _f.range }));
                }
                //default value missing
            }
            else {
                this.event.file.addDiagnostic(Object.assign(Object.assign({ file: this.event.file }, DiagnosticMessages_1.DiagnosticMessages.enumValueIsRequired(enumValueKind.replace(/literal$/i, '').toLowerCase())), { range: (_h = ((_g = member.value) !== null && _g !== void 0 ? _g : member)) === null || _h === void 0 ? void 0 : _h.range }));
            }
        }
    }
    /**
     * Find statements defined at the top level (or inside a namespace body) that are not allowed to be there
     */
    flagTopLevelStatements() {
        const statements = [...this.event.file.ast.statements];
        while (statements.length > 0) {
            const statement = statements.pop();
            if ((0, reflection_1.isNamespaceStatement)(statement)) {
                statements.push(...statement.body.statements);
            }
            else {
                //only allow these statement types
                if (!(0, reflection_1.isFunctionStatement)(statement) &&
                    !(0, reflection_1.isClassStatement)(statement) &&
                    !(0, reflection_1.isEnumStatement)(statement) &&
                    !(0, reflection_1.isInterfaceStatement)(statement) &&
                    !(0, reflection_1.isCommentStatement)(statement) &&
                    !(0, reflection_1.isLibraryStatement)(statement) &&
                    !(0, reflection_1.isImportStatement)(statement) &&
                    !(0, reflection_1.isConstStatement)(statement)) {
                    this.event.file.addDiagnostic(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.unexpectedStatementOutsideFunction()), { range: statement.range }));
                }
            }
        }
    }
}
exports.BrsFileValidator = BrsFileValidator;
//# sourceMappingURL=BrsFileValidator.js.map