/// <reference types="node" />
import { EventEmitter } from "events";
import { Token } from "../lexer";
import { FilterResults } from "./Preprocessor";
import { Manifest } from "./Manifest";
export declare class Preprocessor {
    private parser;
    private _preprocessor;
    readonly events: EventEmitter;
    /**
     * Convenience function to subscribe to the `err` events emitted by `preprocessor.events`.
     * @param errorHandler the function to call for every preprocessing error emitted after subscribing
     * @returns an object with a `dispose` function, used to unsubscribe from errors
     */
    onError(errorHandler: (err: BrsError | ParseError) => void): {
        dispose: () => void;
    };
    /**
     * Convenience function to subscribe to a single `err` event emitted by `preprocessor.events`.
     * @param errorHandler the function to call for the first preprocessing error emitted after subscribing
     */
    onErrorOnce(errorHandler: (err: BrsError | ParseError) => void): void;
    constructor();
    /**
     * Pre-processes a set of tokens, evaluating any conditional compilation directives encountered.
     * @param tokens the set of tokens to process
     * @param manifest the data stored in the found manifest file
     * @returns an array of processed tokens representing a subset of the provided ones
     */
    preprocess(tokens: ReadonlyArray<Token>, manifest: Manifest): FilterResults;
}
import * as Chunk from "./Chunk";
import { BrsError } from "../Error";
import { ParseError } from "../parser";
export { Chunk };
export { Parser } from "./Parser";
export { getManifest, getManifestSync, getBsConst, Manifest } from "./Manifest";
