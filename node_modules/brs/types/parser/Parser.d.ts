/// <reference types="node" />
import { EventEmitter } from "events";
import * as Stmt from "./Statement";
import { Token } from "../lexer";
import { ParseError } from "./ParseError";
/** The results of a Parser's parsing pass. */
interface ParseResults {
    /** The statements produced by the parser. */
    statements: Stmt.Statement[];
    /** The errors encountered by the Parser. */
    errors: ParseError[];
}
export declare class Parser {
    /** Allows consumers to observe errors as they're detected. */
    readonly events: EventEmitter;
    /**
     * A convenience function, equivalent to `new Parser().parse(toParse)`, that parses an array of
     * `Token`s into an abstract syntax tree that can be executed with the `Interpreter`.
     * @param toParse the array of tokens to parse
     * @returns an array of `Statement` objects that together form the abstract syntax tree of the
     *          program
     */
    static parse(toParse: ReadonlyArray<Token>): ParseResults;
    /**
     * Convenience function to subscribe to the `err` events emitted by `parser.events`.
     * @param errorHandler the function to call for every Parser error emitted after subscribing
     * @returns an object with a `dispose` function, used to unsubscribe from errors
     */
    onError(errorHandler: (err: ParseError) => void): {
        dispose: () => void;
    };
    /**
     * Convenience function to subscribe to a single `err` event emitted by `parser.events`.
     * @param errorHandler the function to call for the first Parser error emitted after subscribing
     */
    onErrorOnce(errorHandler: (err: ParseError) => void): void;
    /**
     * Parses an array of `Token`s into an abstract syntax tree that can be executed with the `Interpreter`.
     * @param toParse the array of tokens to parse
     * @returns an array of `Statement` objects that together form the abstract syntax tree of the
     *          program
     */
    parse(toParse: ReadonlyArray<Token>): ParseResults;
}
export {};
