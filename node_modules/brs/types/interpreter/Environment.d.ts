import { Identifier } from "../lexer";
import { BrsType, RoAssociativeArray } from "../brsTypes";
/** The logical region from a particular variable or function that defines where it may be accessed from. */
export declare enum Scope {
    /** The set of native functions that are always accessible, e.g. `RebootSystem`. */
    Global = 0,
    /** The set of named functions accessible from a set of files compiled together. */
    Module = 1,
    /** The set of variables (including anonymous functions) accessible *only* from within a function body. */
    Function = 2
}
/** An error thrown when attempting to access an uninitialized variable. */
export declare class NotFound extends Error {
    constructor(reason: string);
}
/** Holds a set of values in multiple scopes and provides access operations to them. */
export declare class Environment {
    /**
     * Functions that are always accessible.
     * @see Scope.Global
     */
    private global;
    /**
     * Named functions that are compiled together into a single module.
     * @see Scope.Module
     */
    private module;
    /**
     * Variables and anonymous functions accessible only within a function's body.
     * @see Scope.Function
     */
    private function;
    /** The BrightScript `m` pointer, analogous to JavaScript's `this` pointer. */
    private mPointer;
    /**
     * Stores a `value` for the `name`d variable in the provided `scope`.
     * @param scope The logical region from a particular variable or function that defines where it may be accessed from
     * @param name the name of the variable to define (in the form of an `Identifier`)
     * @param value the value of the variable to define
     */
    define(scope: Scope, name: string, value: BrsType): void;
    /**
     * Sets the value of the special `m` variable, which is analogous to JavaScript's `this`.
     * @param newMPointer the new value to be used for the `m` pointer
     */
    setM(newMPointer: RoAssociativeArray): void;
    /**
     * Retrieves the current value of the special `m` variable, which is analogous to JavaScript's `this`.
     * @returns the current value used for the `m` pointer.
     */
    getM(): RoAssociativeArray;
    /**
     * Removes a variable from this environment's function scope.
     * @param name the name of the variable to remove (in the form of an `Identifier`)
     */
    remove(name: string): void;
    /**
     * Retrieves a variable from this environment, checking each internal scope in order of precedence.
     * @param name the name of the variable to retrieve (in the form of an `Identifier`)
     * @returns the value stored for `name` if any exist
     * @throws a `NotFound` error if no value is stored for `name`
     */
    get(name: Identifier): BrsType;
    /**
     * Determines whether or not a variable exists in this environment.
     * @param name the name of the variable to search for (in the form of an `Identifier`)
     * @param scopeFilter the set of scopes with which to limit searches for `name`
     * @returns `true` if this environment contains `name`, otherwise `false`
     */
    has(name: Identifier, scopeFilter?: Scope[]): boolean;
    /**
     * Creates a clone of the current environment, but without its function-scoped
     * values. Useful for creating sub-environments.
     *
     * The Reference BrightScript Implementation (RBI) doesn't currently create closures when
     * functions are created.  When a function is called, it has access only to:
     *
     * 1. Globally-defined functions (e.g. `RebootSystem`, `UCase`, et. al.)
     * 2. Named functions compiled together into a single "module"
     * 3. Parameters passed into the function
     * 4. The `m` pointer, defined by the way in which a function was called
     *
     * @returns a copy of this environment but with no function-scoped values.
     */
    createSubEnvironment(): Environment;
}
