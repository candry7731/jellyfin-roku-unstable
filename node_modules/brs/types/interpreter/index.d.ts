/// <reference types="node" />
import { EventEmitter } from "events";
import { BrsType, BrsInvalid, BrsBoolean, BrsString, Int32, Uninitialized, RoArray, Callable } from "../brsTypes";
import { Expr, Stmt } from "../parser";
import { BrsError } from "../Error";
import { Environment } from "./Environment";
import { OutputProxy } from "./OutputProxy";
import { Runtime } from "../parser/Statement";
import MemoryFileSystem from "memory-fs";
/** The set of options used to configure an interpreter's execution. */
export interface ExecutionOptions {
    /** The base path for  */
    root: string;
    stdout: NodeJS.WriteStream;
    stderr: NodeJS.WriteStream;
}
/** The default set of execution options.  Includes the `stdout`/`stderr` pair from the process that invoked `brs`. */
export declare const defaultExecutionOptions: ExecutionOptions;
export declare class Interpreter implements Expr.Visitor<BrsType>, Stmt.Visitor<BrsType> {
    private _environment;
    readonly options: ExecutionOptions;
    readonly stdout: OutputProxy;
    readonly stderr: OutputProxy;
    readonly temporaryVolume: MemoryFileSystem;
    /** Allows consumers to observe errors as they're detected. */
    readonly events: EventEmitter;
    /** The set of errors detected from executing an AST. */
    errors: (BrsError | Runtime)[];
    readonly environment: Environment;
    /**
     * Convenience function to subscribe to the `err` events emitted by `interpreter.events`.
     * @param errorHandler the function to call for every runtime error emitted after subscribing
     * @returns an object with a `dispose` function, used to unsubscribe from errors
     */
    onError(errorHandler: (err: BrsError | Runtime) => void): {
        dispose: () => void;
    };
    /**
     * Convenience function to subscribe to a single `err` event emitted by `interpreter.events`.
     * @param errorHandler the function to call for the first runtime error emitted after subscribing
     */
    onErrorOnce(errorHandler: (err: BrsError | Runtime) => void): void;
    /**
     * Creates a new Interpreter, including any global properties and functions.
     * @param options configuration for the execution, including the streams to use for `stdout` and
     *                `stderr` and the base directory for path resolution
     */
    constructor(options?: ExecutionOptions);
    /**
     * Temporarily sets an interpreter's environment to the provided one, then
     * passes the sub-interpreter to the provided JavaScript function. Always
     * reverts the current interpreter's environment to its original value.
     * @param func the JavaScript function to execute with the sub interpreter.
     */
    inSubEnv(func: (interpreter: Interpreter) => BrsType): BrsType;
    exec(statements: ReadonlyArray<Stmt.Statement>, ...args: BrsType[]): BrsType[];
    visitNamedFunction(statement: Stmt.Function): BrsType;
    visitReturn(statement: Stmt.Return): never;
    visitExpression(statement: Stmt.Expression): BrsType;
    visitPrint(statement: Stmt.Print): BrsType;
    visitAssignment(statement: Stmt.Assignment): BrsType;
    visitBinary(expression: Expr.Binary): BrsBoolean | BrsString | Int32 | import("../brsTypes").Int64 | import("../brsTypes").Float | import("../brsTypes").Double;
    visitBlock(block: Stmt.Block): BrsType;
    visitExitFor(statement: Stmt.ExitFor): never;
    visitExitWhile(expression: Stmt.ExitWhile): never;
    visitCall(expression: Expr.Call): BrsInvalid | BrsBoolean | BrsString | Int32 | import("../brsTypes").Int64 | import("../brsTypes").Float | import("../brsTypes").Double | Callable | import("../brsTypes").AllComponents | Uninitialized;
    visitDottedGet(expression: Expr.DottedGet): BrsInvalid | BrsBoolean | BrsString | Int32 | import("../brsTypes").Int64 | import("../brsTypes").Float | import("../brsTypes").Double | Callable | import("../brsTypes").AllComponents | Uninitialized;
    visitIndexedGet(expression: Expr.IndexedGet): BrsType;
    visitGrouping(expr: Expr.Grouping): BrsType;
    visitFor(statement: Stmt.For): BrsType;
    visitForEach(statement: Stmt.ForEach): BrsType;
    visitWhile(statement: Stmt.While): BrsType;
    visitIf(statement: Stmt.If): BrsType;
    visitAnonymousFunction(func: Expr.Function): BrsType;
    visitLiteral(expression: Expr.Literal): BrsType;
    visitArrayLiteral(expression: Expr.ArrayLiteral): RoArray;
    visitAALiteral(expression: Expr.AALiteral): BrsType;
    visitDottedSet(statement: Stmt.DottedSet): BrsInvalid;
    visitIndexedSet(statement: Stmt.IndexedSet): BrsInvalid;
    visitIncrement(expression: Stmt.Increment): BrsInvalid;
    visitUnary(expression: Expr.Unary): BrsInvalid | BrsBoolean | Int32 | import("../brsTypes").Int64 | import("../brsTypes").Float | import("../brsTypes").Double;
    visitVariable(expression: Expr.Variable): BrsInvalid | BrsBoolean | BrsString | Int32 | import("../brsTypes").Int64 | import("../brsTypes").Float | import("../brsTypes").Double | Callable | import("../brsTypes").AllComponents | Uninitialized;
    evaluate(this: Interpreter, expression: Expr.Expression): BrsType;
    execute(this: Interpreter, statement: Stmt.Statement): BrsType;
    /**
     * Emits an error via this processor's `events` property, then throws it.
     * @param err the ParseError to emit then throw
     */
    private addError;
}
