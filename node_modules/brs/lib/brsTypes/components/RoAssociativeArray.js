"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BrsType_1 = require("../BrsType");
const BrsComponent_1 = require("./BrsComponent");
const Callable_1 = require("../Callable");
const Int32_1 = require("../Int32");
const RoArray_1 = require("./RoArray");
class RoAssociativeArray extends BrsComponent_1.BrsComponent {
    constructor(elements) {
        super("roAssociativeArray");
        this.kind = BrsType_1.ValueKind.Object;
        this.elements = new Map();
        /** Removes all elements from the associative array */
        this.clear = new Callable_1.Callable("clear", {
            signature: {
                args: [],
                returns: BrsType_1.ValueKind.Void,
            },
            impl: (interpreter) => {
                this.elements.clear();
                return BrsType_1.BrsInvalid.Instance;
            },
        });
        /** Removes a given item from the associative array */
        this.delete = new Callable_1.Callable("delete", {
            signature: {
                args: [new Callable_1.StdlibArgument("str", BrsType_1.ValueKind.String)],
                returns: BrsType_1.ValueKind.Boolean,
            },
            impl: (interpreter, str) => {
                let deleted = this.elements.delete(str.value);
                return BrsType_1.BrsBoolean.from(deleted);
            },
        });
        /** Given a key and value, adds an item to the associative array if it doesn't exist
         * Or replaces the value of a key that already exists in the associative array
         */
        this.addreplace = new Callable_1.Callable("addreplace", {
            signature: {
                args: [
                    new Callable_1.StdlibArgument("key", BrsType_1.ValueKind.String),
                    new Callable_1.StdlibArgument("value", BrsType_1.ValueKind.Dynamic),
                ],
                returns: BrsType_1.ValueKind.Void,
            },
            impl: (interpreter, key, value) => {
                this.set(key, value);
                return BrsType_1.BrsInvalid.Instance;
            },
        });
        /** Returns the number of items in the associative array */
        this.count = new Callable_1.Callable("count", {
            signature: {
                args: [],
                returns: BrsType_1.ValueKind.Int32,
            },
            impl: (interpreter) => {
                return new Int32_1.Int32(this.elements.size);
            },
        });
        /** Returns a boolean indicating whether or not a given key exists in the associative array */
        this.doesexist = new Callable_1.Callable("doesexist", {
            signature: {
                args: [new Callable_1.StdlibArgument("str", BrsType_1.ValueKind.String)],
                returns: BrsType_1.ValueKind.Boolean,
            },
            impl: (interpreter, str) => {
                return this.get(str) !== BrsType_1.BrsInvalid.Instance ? BrsType_1.BrsBoolean.True : BrsType_1.BrsBoolean.False;
            },
        });
        /** Appends a new associative array to another. If two keys are the same, the value of the original AA is replaced with the new one. */
        this.append = new Callable_1.Callable("append", {
            signature: {
                args: [new Callable_1.StdlibArgument("obj", BrsType_1.ValueKind.Object)],
                returns: BrsType_1.ValueKind.Void,
            },
            impl: (interpreter, obj) => {
                if (!(obj instanceof RoAssociativeArray)) {
                    // TODO: validate against RBI
                    return BrsType_1.BrsInvalid.Instance;
                }
                this.elements = new Map([...this.elements, ...obj.elements]);
                return BrsType_1.BrsInvalid.Instance;
            },
        });
        /** Returns an array of keys from the associative array in lexicographical order */
        this.keys = new Callable_1.Callable("keys", {
            signature: {
                args: [],
                returns: BrsType_1.ValueKind.Object,
            },
            impl: (interpreter) => {
                return new RoArray_1.RoArray(this.getElements());
            },
        });
        /** Returns an array of values from the associative array in lexicographical order */
        this.items = new Callable_1.Callable("items", {
            signature: {
                args: [],
                returns: BrsType_1.ValueKind.Object,
            },
            impl: (interpreter) => {
                return new RoArray_1.RoArray(this.getValues());
            },
        });
        /** Given a key, returns the value associated with that key. This method is case insensitive. */
        this.lookup = new Callable_1.Callable("lookup", {
            signature: {
                args: [new Callable_1.StdlibArgument("key", BrsType_1.ValueKind.String)],
                returns: BrsType_1.ValueKind.Dynamic,
            },
            impl: (interpreter, key) => {
                let lKey = key.value.toLowerCase();
                return this.get(new BrsType_1.BrsString(lKey));
            },
        });
        elements.forEach(member => this.elements.set(member.name.value.toLowerCase(), member.value));
        this.registerMethods([
            this.clear,
            this.delete,
            this.addreplace,
            this.count,
            this.doesexist,
            this.append,
            this.keys,
            this.items,
            this.lookup,
        ]);
    }
    toString(parent) {
        if (parent) {
            return "<Component: roAssociativeArray>";
        }
        return [
            "<Component: roAssociativeArray> =",
            "{",
            ...Array.from(this.elements.keys()).map(key => `    ${key}: ${this.elements.get(key).toString(this)}`),
            "}",
        ].join("\n");
    }
    equalTo(other) {
        return BrsType_1.BrsBoolean.False;
    }
    getValue() {
        return this.elements;
    }
    getElements() {
        return Array.from(this.elements.keys())
            .sort()
            .map(key => new BrsType_1.BrsString(key));
    }
    getValues() {
        return Array.from(this.elements.values())
            .sort()
            .map((value) => value);
    }
    get(index) {
        if (index.kind !== BrsType_1.ValueKind.String) {
            throw new Error("Associative array indexes must be strings");
        }
        // TODO: this works for now, in that a property with the same name as a method essentially
        // overwrites the method. The only reason this doesn't work is that getting a method from an
        // associative array and _not_ calling it returns `invalid`, but calling it returns the
        // function itself. I'm not entirely sure why yet, but it's gotta have something to do with
        // how methods are implemented within RBI.
        //
        // Are they stored separately from elements, like they are here? Or does
        // `Interpreter#visitCall` need to check for `invalid` in its callable, then try to find a
        // method with the desired name separately? That last bit would work but it's pretty gross.
        // That'd allow roArrays to have methods with the methods not accessible via `arr["count"]`.
        // Same with RoAssociativeArrays I guess.
        return (this.elements.get(index.value.toLowerCase()) ||
            this.getMethod(index.value) ||
            BrsType_1.BrsInvalid.Instance);
    }
    set(index, value) {
        if (index.kind !== BrsType_1.ValueKind.String) {
            throw new Error("Associative array indexes must be strings");
        }
        this.elements.set(index.value.toLowerCase(), value);
        return BrsType_1.BrsInvalid.Instance;
    }
}
exports.RoAssociativeArray = RoAssociativeArray;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm9Bc3NvY2lhdGl2ZUFycmF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Jyc1R5cGVzL2NvbXBvbmVudHMvUm9Bc3NvY2lhdGl2ZUFycmF5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsd0NBQW9GO0FBQ3BGLGlEQUEyRDtBQUUzRCwwQ0FBdUQ7QUFFdkQsb0NBQWlDO0FBQ2pDLHVDQUFvQztBQVVwQyxNQUFhLGtCQUFtQixTQUFRLDJCQUFZO0lBSWhELFlBQVksUUFBb0I7UUFDNUIsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFKdkIsU0FBSSxHQUFHLG1CQUFTLENBQUMsTUFBTSxDQUFDO1FBQ3pCLGFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBbUIsQ0FBQztRQXVGOUMsc0RBQXNEO1FBQzlDLFVBQUssR0FBRyxJQUFJLG1CQUFRLENBQUMsT0FBTyxFQUFFO1lBQ2xDLFNBQVMsRUFBRTtnQkFDUCxJQUFJLEVBQUUsRUFBRTtnQkFDUixPQUFPLEVBQUUsbUJBQVMsQ0FBQyxJQUFJO2FBQzFCO1lBQ0QsSUFBSSxFQUFFLENBQUMsV0FBd0IsRUFBRSxFQUFFO2dCQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUN0QixPQUFPLG9CQUFVLENBQUMsUUFBUSxDQUFDO1lBQy9CLENBQUM7U0FDSixDQUFDLENBQUM7UUFFSCxzREFBc0Q7UUFDOUMsV0FBTSxHQUFHLElBQUksbUJBQVEsQ0FBQyxRQUFRLEVBQUU7WUFDcEMsU0FBUyxFQUFFO2dCQUNQLElBQUksRUFBRSxDQUFDLElBQUkseUJBQWMsQ0FBQyxLQUFLLEVBQUUsbUJBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDbkQsT0FBTyxFQUFFLG1CQUFTLENBQUMsT0FBTzthQUM3QjtZQUNELElBQUksRUFBRSxDQUFDLFdBQXdCLEVBQUUsR0FBYyxFQUFFLEVBQUU7Z0JBQy9DLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxR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