"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const brsTypes_1 = require("../brsTypes");
const url_1 = require("url");
const nanomatch = __importStar(require("nanomatch"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
/*
 * Returns a memfs volume based on the brs path uri.  For example, passing in
 * "tmp:/test.txt" will return the memfs temporary volume on the interpreter.
 *
 * Returns invalid in no appopriate volume is found for the path
 */
function getVolumeByPath(interpreter, path) {
    try {
        const protocol = new url_1.URL(path).protocol;
        if (protocol === "tmp:") {
            return interpreter.temporaryVolume;
        }
        if (protocol === "pkg:") {
            return fs;
        }
    }
    catch (err) {
        return null;
    }
    return null;
}
exports.getVolumeByPath = getVolumeByPath;
/*
 * Returns a memfs file path from a brs file uri
 *   ex. "tmp:/test/test1.txt" -> "/test/test1.txt"
 */
function getPath(fileUri) {
    return new url_1.URL(fileUri).pathname;
}
exports.getPath = getPath;
/** Copies a file from src to dst, return true if successful */
exports.CopyFile = new brsTypes_1.Callable("CopyFile", {
    signature: {
        args: [
            new brsTypes_1.StdlibArgument("source", brsTypes_1.ValueKind.String),
            new brsTypes_1.StdlibArgument("destination", brsTypes_1.ValueKind.String),
        ],
        returns: brsTypes_1.ValueKind.Boolean,
    },
    impl: (interpreter, src, dst) => {
        const srcVolume = getVolumeByPath(interpreter, src.value);
        if (srcVolume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const dstVolume = getVolumeByPath(interpreter, dst.value);
        if (dstVolume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const srcMemfsPath = getPath(src.value);
        const dstMemfsPath = getPath(dst.value);
        try {
            let contents = srcVolume.readFileSync(srcMemfsPath);
            dstVolume.writeFileSync(dstMemfsPath, contents);
            return brsTypes_1.BrsBoolean.True;
        }
        catch (err) {
            return brsTypes_1.BrsBoolean.False;
        }
    },
});
/** Copies a file from src to dst, return true if successful */
exports.MoveFile = new brsTypes_1.Callable("MoveFile", {
    signature: {
        args: [
            new brsTypes_1.StdlibArgument("source", brsTypes_1.ValueKind.String),
            new brsTypes_1.StdlibArgument("destination", brsTypes_1.ValueKind.String),
        ],
        returns: brsTypes_1.ValueKind.Boolean,
    },
    impl: (interpreter, src, dst) => {
        const srcVolume = getVolumeByPath(interpreter, src.value);
        if (srcVolume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const dstVolume = getVolumeByPath(interpreter, dst.value);
        if (dstVolume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const srcMemfsPath = getPath(src.value);
        const dstMemfsPath = getPath(dst.value);
        try {
            let contents = srcVolume.readFileSync(srcMemfsPath);
            dstVolume.writeFileSync(dstMemfsPath, contents);
            srcVolume.unlinkSync(srcMemfsPath);
            return brsTypes_1.BrsBoolean.True;
        }
        catch (err) {
            return brsTypes_1.BrsBoolean.False;
        }
    },
});
/** Deletes a file, return true if successful */
exports.DeleteFile = new brsTypes_1.Callable("DeleteFile", {
    signature: {
        args: [new brsTypes_1.StdlibArgument("file", brsTypes_1.ValueKind.String)],
        returns: brsTypes_1.ValueKind.Boolean,
    },
    impl: (interpreter, file) => {
        const volume = getVolumeByPath(interpreter, file.value);
        if (volume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const memfsPath = getPath(file.value);
        try {
            volume.unlinkSync(memfsPath);
            return brsTypes_1.BrsBoolean.True;
        }
        catch (err) {
            return brsTypes_1.BrsBoolean.False;
        }
    },
});
/** Deletes a directory (if empty), return true if successful */
exports.DeleteDirectory = new brsTypes_1.Callable("DeleteDirectory", {
    signature: {
        args: [new brsTypes_1.StdlibArgument("dir", brsTypes_1.ValueKind.String)],
        returns: brsTypes_1.ValueKind.Boolean,
    },
    impl: (interpreter, dir) => {
        const volume = getVolumeByPath(interpreter, dir.value);
        if (volume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const memfsPath = getPath(dir.value);
        try {
            volume.rmdirSync(memfsPath);
            return brsTypes_1.BrsBoolean.True;
        }
        catch (err) {
            return brsTypes_1.BrsBoolean.False;
        }
    },
});
/** Creates a directory, return true if successful */
exports.CreateDirectory = new brsTypes_1.Callable("CreateDirectory", {
    signature: {
        args: [new brsTypes_1.StdlibArgument("dir", brsTypes_1.ValueKind.String)],
        returns: brsTypes_1.ValueKind.Boolean,
    },
    impl: (interpreter, dir) => {
        const volume = getVolumeByPath(interpreter, dir.value);
        if (volume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const memfsPath = getPath(dir.value);
        try {
            volume.mkdirSync(memfsPath);
            return brsTypes_1.BrsBoolean.True;
        }
        catch (err) {
            return brsTypes_1.BrsBoolean.False;
        }
    },
});
/** Stubbed function for formatting a drive; always returns false */
exports.FormatDrive = new brsTypes_1.Callable("FormatDrive", {
    signature: {
        args: [
            new brsTypes_1.StdlibArgument("drive", brsTypes_1.ValueKind.String),
            new brsTypes_1.StdlibArgument("fs_type", brsTypes_1.ValueKind.String),
        ],
        returns: brsTypes_1.ValueKind.Boolean,
    },
    impl: (interpreter, dir) => {
        if (process.env.NODE_ENV !== "test") {
            console.error("`FormatDrive` is not implemented in `brs`.");
        }
        return brsTypes_1.BrsBoolean.False;
    },
});
/** Returns an array of paths in a directory */
exports.ListDir = new brsTypes_1.Callable("ListDir", {
    signature: {
        args: [new brsTypes_1.StdlibArgument("path", brsTypes_1.ValueKind.String)],
        returns: brsTypes_1.ValueKind.Object,
    },
    impl: (interpreter, path) => {
        const volume = getVolumeByPath(interpreter, path.value);
        if (volume === null) {
            return new brsTypes_1.RoArray([]);
        }
        const memfsPath = getPath(path.value);
        try {
            let subPaths = volume.readdirSync(memfsPath).map(s => new brsTypes_1.BrsString(s));
            return new brsTypes_1.RoArray(subPaths);
        }
        catch (err) {
            return new brsTypes_1.RoArray([]);
        }
    },
});
/** Reads ascii file from file system. */
exports.ReadAsciiFile = new brsTypes_1.Callable("ReadAsciiFile", {
    signature: {
        args: [new brsTypes_1.StdlibArgument("filepath", brsTypes_1.ValueKind.String)],
        returns: brsTypes_1.ValueKind.String,
    },
    impl: (interpreter, filepath, text) => {
        const volume = getVolumeByPath(interpreter, filepath.value);
        if (volume === null) {
            return new brsTypes_1.BrsString("");
        }
        const memfsPath = getPath(filepath.value);
        return new brsTypes_1.BrsString(volume.readFileSync(memfsPath).toString());
    },
});
/** Writes a string to a temporary file. */
exports.WriteAsciiFile = new brsTypes_1.Callable("WriteAsciiFile", {
    signature: {
        args: [
            new brsTypes_1.StdlibArgument("filepath", brsTypes_1.ValueKind.String),
            new brsTypes_1.StdlibArgument("text", brsTypes_1.ValueKind.String),
        ],
        returns: brsTypes_1.ValueKind.Boolean,
    },
    impl: (interpreter, filepath, text) => {
        const volume = getVolumeByPath(interpreter, filepath.value);
        if (volume === null) {
            return brsTypes_1.BrsBoolean.False;
        }
        const memfsPath = getPath(filepath.value);
        volume.writeFileSync(memfsPath, text.value);
        return brsTypes_1.BrsBoolean.True;
    },
});
/** Searches a directory for filenames that match a certain pattern. */
exports.MatchFiles = new brsTypes_1.Callable("MatchFiles", {
    signature: {
        args: [
            new brsTypes_1.StdlibArgument("path", brsTypes_1.ValueKind.String),
            new brsTypes_1.StdlibArgument("pattern_in", brsTypes_1.ValueKind.String),
        ],
        returns: brsTypes_1.ValueKind.Object,
    },
    impl: (interpreter, pathArg, patternIn) => {
        let volume = getVolumeByPath(interpreter, pathArg.value);
        if (volume == null) {
            // TODO: replace with RoList when that's implemented
            return new brsTypes_1.RoArray([]);
        }
        let localPath = path.join(interpreter.options.root, getPath(pathArg.value));
        try {
            let knownFiles = fs.readdirSync(localPath, "utf8");
            let matchedFiles = nanomatch.match(knownFiles, patternIn.value, {
                nocase: true,
                nodupes: true,
                noglobstar: true,
                nonegate: true,
            });
            matchedFiles = (matchedFiles || []).map((match) => new brsTypes_1.BrsString(match));
            // TODO: replace with RoList when that's implemented
            return new brsTypes_1.RoArray(matchedFiles);
        }
        catch (err) {
            // TODO: replace with RoList when that's implemented
            return new brsTypes_1.RoArray([]);
        }
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGRsaWIvRmlsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSwwQ0FBa0c7QUFFbEcsNkJBQTBCO0FBRTFCLHFEQUF1QztBQUV2Qyx1Q0FBeUI7QUFDekIsMkNBQTZCO0FBSTdCOzs7OztHQUtHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLFdBQXdCLEVBQUUsSUFBWTtJQUNsRSxJQUFJO1FBQ0EsTUFBTSxRQUFRLEdBQUcsSUFBSSxTQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDO1FBQ3hDLElBQUksUUFBUSxLQUFLLE1BQU0sRUFBRTtZQUNyQixPQUFPLFdBQVcsQ0FBQyxlQUFlLENBQUM7U0FDdEM7UUFDRCxJQUFJLFFBQVEsS0FBSyxNQUFNLEVBQUU7WUFDckIsT0FBTyxFQUFFLENBQUM7U0FDYjtLQUNKO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDVixPQUFPLElBQUksQ0FBQztLQUNmO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDaEIsQ0FBQztBQWJELDBDQWFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLE9BQWU7SUFDbkMsT0FBTyxJQUFJLFNBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDckMsQ0FBQztBQUZELDBCQUVDO0FBRUQsK0RBQStEO0FBQ2xELFFBQUEsUUFBUSxHQUFHLElBQUksbUJBQVEsQ0FBQyxVQUFVLEVBQUU7SUFDN0MsU0FBUyxFQUFFO1FBQ1AsSUFBSSxFQUFFO1lBQ0YsSUFBSSx5QkFBYyxDQUFDLFFBQVEsRUFBRSxvQkFBUyxDQUFDLE1BQU0sQ0FBQztZQUM5QyxJQUFJLHlCQUFjLENBQUMsYUFBYSxFQUFFLG9CQUFTLENBQUMsTUFBTSxDQUFDO1NBQ3REO1FBQ0QsT0FBTyxFQUFFLG9CQUFTLENBQUMsT0FBTztLQUM3QjtJQUNELElBQUksRUFBRSxDQUFDLFdBQXdCLEVBQUUs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