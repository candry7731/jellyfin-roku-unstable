"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const brs = __importStar(require("../"));
const brsTypes_1 = require("../brsTypes");
const File_1 = require("./File");
/**
 * Runs a file (or set of files) with the provided arguments, returning either the value returned by those files'
 * `main` function or `invalid` if an error occurs.
 *
 * @param interpreter the interpreter hosting this call to `Run`
 * @param filenames a list of files to lex, parse, and run
 * @param args the arguments to pass into the found `main` function
 *
 * @returns the value returned by the executed file(s) if no errors are detected, otherwise `invalid`
 */
function runFiles(interpreter, filenames, args) {
    let volumes = filenames.map(filename => File_1.getVolumeByPath(interpreter, filename.value));
    let pathsToFiles = filenames.map(filename => path.join(interpreter.options.root, File_1.getPath(filename.value)));
    // if the file-to-run doesn't exist, RBI returns invalid
    if (!volumes.every(volume => volume != null)) {
        return brsTypes_1.BrsInvalid.Instance;
    }
    try {
        let results = brs.executeSync(pathsToFiles, interpreter.options, args);
        return results[0] || brsTypes_1.BrsInvalid.Instance;
    }
    catch (err) {
        // swallow errors and just return invalid; RBI returns invalid for "file doesn't exist" errors,
        // syntax errors, etc.
        return brsTypes_1.BrsInvalid.Instance;
    }
}
/**
 * Creates several copies of the provided signature and implementation pair, simulating variadic types by creating a
 * function that accepts zero args, one that accepts one arg, one that accepts two args, (â€¦).
 *
 * @param signatureAndImpl the base signature and implementation to make variadic
 *
 * @returns an array containing psuedo-variadic versions of the provided signature and implementation
 */
function variadic(signatureAndImpl) {
    let { signature, impl } = signatureAndImpl;
    return [
        signatureAndImpl,
        ...new Array(10).fill(0).map((_, numArgs) => {
            return {
                signature: {
                    args: [
                        ...signature.args,
                        ...new Array(numArgs)
                            .fill(0)
                            .map((_, i) => new brsTypes_1.StdlibArgument(`arg${i}`, brsTypes_1.ValueKind.Dynamic)),
                    ],
                    returns: signature.returns,
                },
                impl: impl,
            };
        }),
    ];
}
exports.Run = new brsTypes_1.Callable("Run", ...variadic({
    signature: {
        args: [new brsTypes_1.StdlibArgument("filename", brsTypes_1.ValueKind.String)],
        returns: brsTypes_1.ValueKind.Dynamic,
    },
    impl: (interpreter, filename, ...args) => {
        return runFiles(interpreter, [filename], args);
    },
}), ...variadic({
    signature: {
        args: [new brsTypes_1.StdlibArgument("filenamearray", brsTypes_1.ValueKind.Object)],
        returns: brsTypes_1.ValueKind.Dynamic,
    },
    impl: (interpreter, filenamearray, ...args) => {
        if (filenamearray instanceof brsTypes_1.RoArray &&
            filenamearray.getElements().every(brsTypes_1.isBrsString)) {
            return runFiles(interpreter, filenamearray.getElements(), args);
        }
        // RBI seems to hard-reboot when passed a non-empty associative array, but returns invalid for empty
        // AA's. Let's return invalid to be safe.
        return brsTypes_1.BrsInvalid.Instance;
    },
}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUnVuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3N0ZGxpYi9SdW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBRTdCLHlDQUEyQjtBQUMzQiwwQ0FVcUI7QUFFckIsaUNBQWtEO0FBR2xEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQVMsUUFBUSxDQUFDLFdBQXdCLEVBQUUsU0FBc0IsRUFBRSxJQUFlO0lBQy9FLElBQUksT0FBTyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxzQkFBZSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN0RixJQUFJLFlBQVksR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsY0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUMvRCxDQUFDO0lBRUYsd0RBQXdEO0lBQ3hELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxFQUFFO1FBQzFDLE9BQU8scUJBQVUsQ0FBQyxRQUFRLENBQUM7S0FDOUI7SUFFRCxJQUFJO1FBQ0EsSUFBSSxPQUFPLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN2RSxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxxQkFBVSxDQUFDLFFBQVEsQ0FBQztLQUM1QztJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1YsK0ZBQStGO1FBQy9GLHNCQUFzQjtRQUN0QixPQUFPLHFCQUFVLENBQUMsUUFBUSxDQUFDO0tBQzlCO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFTLFFBQVEsQ0FBQyxnQkFBNEM7SUFDMUQsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQztJQUMzQyxPQUFPO1FBQ0gsZ0JBQWdCO1FBQ2hCLEdBQUcsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRTtZQUN4QyxPQUFPO2dCQUNILFNBQVMsRUFBRTtvQkFDUCxJQUFJLEVBQUU7d0JBQ0YsR0FBRyxTQUFTLENBQUMsSUFBSTt3QkFDakIsR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUM7NkJBQ2hCLElBQUksQ0FBQyxDQUFDLENBQUM7NkJBQ1AsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSx5QkFBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsb0JBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztxQkFDdkU7b0JBQ0QsT0FBTyxFQUFFLFNBQVMsQ0FBQyxPQUFPO2lCQUM3QjtnQkFDRCxJQUFJLEVBQUUsSUFBSTthQUNiLENBQUM7UUFDTixDQUFDLENBQUM7S0FDTCxDQUFDO0FBQ04sQ0FBQztBQUVZLFFBQUEsR0FBRyxHQUFHLElBQUksbUJBQVEsQ0FDM0IsS0FBSyxFQUNMLEdBQUcsUUFBUSxDQUFDO0lBQ1IsU0FBUyxFQUFFO1FBQ1AsSUFBSSxFQUFFLENBQUMsSUFBSSx5QkFBYyxDQUFDLFVBQVUsRUFBRSxvQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3hELE9BQU8sRUFBRSxvQkFBUyxDQUFDLE9BQU87S0FDN0I7SUFDRCxJQUFJLEVBQUUsQ0FBQyxXQUF3QixFQUFFLFFBQW1CLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRTtRQUN4RSxPQUFPLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuRCxDQUFDO0NBQ0osQ0FBQyxFQUNGLEdBQUcsUUFBUSxDQUFDO0lBQ1IsU0FBUyxFQUFFO1FBQ1AsSUFBSSxFQUFFLENBQUMsSUFBSSx5QkFBYyxDQUFDLGVBQWUsRUFBRSxvQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdELE9BQU8sRUFBRSxvQkFBUyxDQUFDLE9BQU87S0FDN0I7SUFDRCxJQUFJLEVBQUUsQ0FBQyxXQUF3QixFQUFFLGFBQTJCLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRTtRQUNoRixJQUNJLGFBQWEsWUFBWSxrQkFBTztZQUNoQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDLHNCQUFXLENBQUMsRUFDaEQ7WUFDRSxPQUFPLFFBQVEsQ0FBQyxXQUFXLEVBQUUsYUFBYSxDQUFDLFdBQVcsRUFBaUIsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNsRjtRQUVELG9HQUFvRztRQUNwRyx5Q0FBeUM7UUFDekMsT0FBTyxxQkFBVSxDQUFDLFFBQVEsQ0FBQztJQUMvQixDQUFDO0NBQ0osQ0FBQyxDQUNMLENBQUMifQ==