"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const readline = __importStar(require("readline"));
const util_1 = require("util");
const p_settle_1 = __importDefault(require("p-settle"));
const readFile = util_1.promisify(fs.readFile);
const lexer_1 = require("./lexer");
const PP = __importStar(require("./preprocessor"));
exports.preprocessor = PP;
const parser_1 = require("./parser");
const interpreter_1 = require("./interpreter");
const _lexer = __importStar(require("./lexer"));
exports.lexer = _lexer;
const BrsTypes = __importStar(require("./brsTypes"));
exports.types = BrsTypes;
const _parser = __importStar(require("./parser"));
exports.parser = _parser;
/**
 * Executes a BrightScript file by path and writes its output to the streams
 * provided in `options`.
 *
 * @param filename the absolute path to the `.brs` file to be executed
 * @param options configuration for the execution, including the streams to use for `stdout` and
 *                `stderr` and the base directory for path resolution
 *
 * @returns a `Promise` that will be resolve if `filename` is successfully
 *          executed, or be rejected if an error occurs.
 */
function execute(filenames, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const executionOptions = Object.assign(interpreter_1.defaultExecutionOptions, options);
        let manifest = yield PP.getManifest(executionOptions.root);
        // wait for all files to be read, lexed, and parsed, but don't exit on the first error
        let parsedFiles = yield p_settle_1.default(filenames.map((filename) => __awaiter(this, void 0, void 0, function* () {
            let contents;
            try {
                contents = yield readFile(filename, "utf-8");
            }
            catch (err) {
                return Promise.reject({
                    message: `brs: can't open file '${filename}': [Errno ${err.errno}]`,
                });
            }
            let lexer = new lexer_1.Lexer();
            let preprocessor = new PP.Preprocessor();
            let parser = new parser_1.Parser();
            [lexer, preprocessor, parser].forEach(emitter => emitter.onError(logError));
            let scanResults = lexer.scan(contents, filename);
            if (scanResults.errors.length > 0) {
                return Promise.reject({
                    message: "Error occurred during lexing",
                });
            }
            let preprocessResults = preprocessor.preprocess(scanResults.tokens, manifest);
            if (preprocessResults.errors.length > 0) {
                return Promise.reject({
                    message: "Error occurred during pre-processing",
                });
            }
            let parseResults = parser.parse(preprocessResults.processedTokens);
            if (parseResults.errors.length > 0) {
                return Promise.reject({
                    message: "Error occurred parsing",
                });
            }
            return Promise.resolve(parseResults.statements);
        })));
        // don't execute anything if there were reading, lexing, or parsing errors
        if (parsedFiles.some(file => file.isRejected)) {
            return Promise.reject({
                messages: parsedFiles
                    .filter(file => file.isRejected)
                    .map(rejection => rejection.reason.message),
            });
        }
        // combine statements from all files into one array
        let statements = parsedFiles
            .map(file => file.value || [])
            .reduce((allStatements, fileStatements) => [...allStatements, ...fileStatements], []);
        // execute them
        const interpreter = new interpreter_1.Interpreter(executionOptions);
        interpreter.onError(logError);
        return interpreter.exec(statements);
    });
}
exports.execute = execute;
/**
 * A synchronous version of `execute`. Executes a BrightScript file by path and writes its output to the streams
 * provided in `options`.
 *
 * @param filename the paths to BrightScript files to execute synchronously
 * @param options configuration for the execution, including the streams to use for `stdout` and
 *                `stderr` and the base directory for path resolution
 * @param args the set of arguments to pass to the `main` function declared in one of the provided filenames
 *
 * @returns the value returned by the executed file(s)
 */
function executeSync(filenames, options, args) {
    const executionOptions = Object.assign(interpreter_1.defaultExecutionOptions, options);
    const interpreter = new interpreter_1.Interpreter(executionOptions); // shared between files
    let manifest = PP.getManifestSync(executionOptions.root);
    let allStatements = filenames
        .map(filename => {
        let contents = fs.readFileSync(filename, "utf8");
        let scanResults = lexer_1.Lexer.scan(contents, filename);
        let preprocessor = new PP.Preprocessor();
        let preprocessorResults = preprocessor.preprocess(scanResults.tokens, manifest);
        return parser_1.Parser.parse(preprocessorResults.processedTokens).statements;
    })
        .reduce((allStatements, statements) => [...allStatements, ...statements], []);
    return interpreter.exec(allStatements, ...args);
}
exports.executeSync = executeSync;
/**
 * Launches an interactive read-execute-print loop, which reads input from
 * `stdin` and executes it.
 *
 * **NOTE:** Currently limited to single-line inputs :(
 */
function repl() {
    const replInterpreter = new interpreter_1.Interpreter();
    replInterpreter.onError(logError);
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    rl.setPrompt("brs> ");
    rl.on("line", line => {
        let results = run(line, interpreter_1.defaultExecutionOptions, replInterpreter);
        if (results) {
            results.map(result => console.log(result.toString()));
        }
        rl.prompt();
    });
    rl.prompt();
}
exports.repl = repl;
/**
 * Runs an arbitrary string of BrightScript code.
 * @param contents the BrightScript code to lex, parse, and interpret.
 * @param options the streams to use for `stdout` and `stderr`. Mostly used for
 *                testing.
 * @param interpreter an interpreter to use when executing `contents`. Required
 *                    for `repl` to have persistent state between user inputs.
 * @returns an array of statement execution results, indicating why each
 *          statement exited and what its return value was, or `undefined` if
 *          `interpreter` threw an Error.
 */
function run(contents, options = interpreter_1.defaultExecutionOptions, interpreter) {
    const lexer = new lexer_1.Lexer();
    const parser = new parser_1.Parser();
    lexer.onError(logError);
    parser.onError(logError);
    const scanResults = lexer.scan(contents, "REPL");
    if (scanResults.errors.length > 0) {
        return;
    }
    const parseResults = parser.parse(scanResults.tokens);
    if (parseResults.errors.length > 0) {
        return;
    }
    if (parseResults.statements.length === 0) {
        return;
    }
    try {
        return interpreter.exec(parseResults.statements);
    }
    catch (e) {
        //options.stderr.write(e.message);
        return;
    }
}
/**
 * Logs a detected BRS error to stderr.
 * @param err the error to log to `stderr`
 */
function logError(err) {
    console.error(err.format());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1Q0FBeUI7QUFDekIsbURBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQyx3REFBK0I7QUFDL0IsTUFBTSxRQUFRLEdBQUcsZ0JBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7QUFFeEMsbUNBQWdDO0FBQ2hDLG1EQUFxQztBQVN0QiwwQkFBWTtBQVIzQixxQ0FBa0M7QUFDbEMsK0NBQXVGO0FBR3ZGLGdEQUFrQztBQUNmLHVCQUFLO0FBQ3hCLHFEQUF1QztBQUNsQix5QkFBSztBQUUxQixrREFBb0M7QUFDaEIseUJBQU07QUFFMUI7Ozs7Ozs7Ozs7R0FVRztBQUNILFNBQXNCLE9BQU8sQ0FBQyxTQUFtQixFQUFFLE9BQWtDOztRQUNqRixNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMscUNBQXVCLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFekUsSUFBSSxRQUFRLEdBQUcsTUFBTSxFQUFFLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTNELHNGQUFzRjtRQUN0RixJQUFJLFdBQVcsR0FBRyxNQUFNLGtCQUFPLENBQzNCLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBTSxRQUFRLEVBQUMsRUFBRTtZQUMzQixJQUFJLFFBQVEsQ0FBQztZQUNiLElBQUk7Z0JBQ0EsUUFBUSxHQUFHLE1BQU0sUUFBUSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUNoRDtZQUFDLE9BQU8sR0FBRyxFQUFFO2dCQUNWLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQztvQkFDbEIsT0FBTyxFQUFFLHlCQUF5QixRQUFRLGFBQWEsR0FBRyxDQUFDLEtBQUssR0FBRztpQkFDdEUsQ0FBQyxDQUFDO2FBQ047WUFFRCxJQUFJLEtBQUssR0FBRyxJ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