"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const parser_1 = require("../parser");
const lexer_1 = require("../lexer");
const Error_1 = require("../Error");
/**
 * A simple pre-processor that executes BrightScript's conditional compilation directives by
 * selecting chunks of tokens to be considered for later evaluation.
 */
class Preprocessor {
    constructor() {
        this.constants = new Map();
        /** Allows consumers to observe errors as they're detected. */
        this.events = new events_1.EventEmitter();
        /** The set of errors encountered when pre-processing conditional compilation directives. */
        this.errors = [];
    }
    /**
     * Emits an error via this processor's `events` property, then throws it.
     * @param err the ParseError to emit then throw
     */
    addError(err) {
        this.errors.push(err);
        this.events.emit("err", err);
        throw err;
    }
    /**
     * Filters the tokens contained within a set of chunks based on a set of constants.
     * @param chunks the chunks from which to retrieve tokens
     * @param bsConst the set of constants defined in a BrightScript `manifest` file's `bs_const` property
     * @returns an object containing an array of `errors` and an array of `processedTokens` filtered by conditional
     *          compilation directives included within
     */
    filter(chunks, bsConst) {
        this.constants = new Map(bsConst);
        return {
            processedTokens: chunks
                .map(chunk => chunk.accept(this))
                .reduce((allTokens, chunkTokens) => [...allTokens, ...chunkTokens], []),
            errors: this.errors,
        };
    }
    /**
     * Handles a simple chunk of BrightScript tokens by returning the tokens contained within.
     * @param chunk the chunk to extract tokens from
     * @returns the array of tokens contained within `chunk`
     */
    visitBrightScript(chunk) {
        return chunk.tokens;
    }
    /**
     * Handles a BrightScript `#const` directive, creating a variable in-scope only for the
     * conditional compilation pass.
     * @param chunk the `#const` directive, including the name and variable to use for the constant
     * @returns an empty array, since `#const` directives are always removed from the evaluated script.
     */
    visitDeclaration(chunk) {
        if (this.constants.has(chunk.name.text)) {
            return this.addError(new Error_1.BrsError(`Attempting to re-declare #const with name '${chunk.name.text}'`, chunk.name.location));
        }
        let value;
        switch (chunk.value.kind) {
            case lexer_1.Lexeme.True:
                value = true;
                break;
            case lexer_1.Lexeme.False:
                value = false;
                break;
            case lexer_1.Lexeme.Identifier:
                if (this.constants.has(chunk.value.text)) {
                    value = this.constants.get(chunk.value.text);
                    break;
                }
                return this.addError(new Error_1.BrsError(`Attempting to create #const alias of '${chunk.value.text}', but no such #const exists`, chunk.value.location));
            default:
                return this.addError(new Error_1.BrsError("#const declarations can only have values of `true`, `false`, or other #const names", chunk.value.location));
        }
        this.constants.set(chunk.name.text, value);
        return [];
    }
    /**
     * Throws an error, stopping "compilation" of the program.
     * @param chunk the error to report to users
     * @throws a JavaScript error with the provided message
     */
    visitError(chunk) {
        return this.addError(new parser_1.ParseError(chunk.hashError, chunk.message));
    }
    /**
     * Produces tokens from a branch of a conditional-compilation `#if`, or no tokens if no branches evaluate to `true`.
     * @param chunk the `#if` directive, any `#else if` or `#else` directives, and their associated BrightScript chunks.
     * @returns an array of tokens to include in the final executed script.
     */
    visitIf(chunk) {
        if (this.evaluateCondition(chunk.condition)) {
            return chunk.thenChunks
                .map(chunk => chunk.accept(this))
                .reduce((allTokens, chunkTokens) => [...allTokens, ...chunkTokens], []);
        }
        else {
            for (const elseIf of chunk.elseIfs) {
                if (this.evaluateCondition(elseIf.condition)) {
                    return elseIf.thenChunks
                        .map(chunk => chunk.accept(this))
                        .reduce((allTokens, chunkTokens) => [...allTokens, ...chunkTokens], []);
                }
            }
        }
        if (chunk.elseChunks) {
            return chunk.elseChunks
                .map(chunk => chunk.accept(this))
                .reduce((allTokens, chunkTokens) => [...allTokens, ...chunkTokens], []);
        }
        return [];
    }
    /**
     * Resolves a token to a JavaScript boolean value, or throws an error.
     * @param token the token to resolve to either `true`, `false`, or an error
     * @throws if attempting to reference an undefined `#const` or if `token` is neither `true`, `false`, nor an identifier.
     */
    evaluateCondition(token) {
        switch (token.kind) {
            case lexer_1.Lexeme.True:
                return true;
            case lexer_1.Lexeme.False:
                return false;
            case lexer_1.Lexeme.Identifier:
                if (this.constants.has(token.text)) {
                    return this.constants.get(token.text);
                }
                return this.addError(new Error_1.BrsError(`Attempting to reference undefined #const with name '${token.text}'`, token.location));
            default:
                return this.addError(new Error_1.BrsError("#if conditionals can only be `true`, `false`, or other #const names", token.location));
        }
    }
}
exports.Preprocessor = Preprocessor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJlcHJvY2Vzc29yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3ByZXByb2Nlc3Nvci9QcmVwcm9jZXNzb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBc0M7QUFHdEMsc0NBQXVDO0FBQ3ZDLG9DQUF5QztBQUN6QyxvQ0FBb0M7QUFVcEM7OztHQUdHO0FBQ0gsTUFBYSxZQUFZO0lBQXpCO1FBQ1ksY0FBUyxHQUFHLElBQUksR0FBRyxFQUFtQixDQUFDO1FBRS9DLDhEQUE4RDtRQUNyRCxXQUFNLEdBQUcsSUFBSSxxQkFBWSxFQUFFLENBQUM7UUFFckMsNEZBQTRGO1FBQzVGLFdBQU0sR0FBaUIsRUFBRSxDQUFDO0lBbUs5QixDQUFDO0lBaktHOzs7T0FHRztJQUNLLFFBQVEsQ0FBQyxHQUFhO1FBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM3QixNQUFNLEdBQUcsQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsTUFBK0IsRUFBRSxPQUE2QjtRQUNqRSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLE9BQU87WUFDSCxlQUFlLEVBQUUsTUFBTTtpQkFDbEIsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDaEMsTUFBTSxDQUNILENBQUMsU0FBa0IsRUFBRSxXQUFvQixFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFLEdBQUcsV0FBVyxDQUFDLEVBQzVFLEVBQUUsQ0FDTDtZQUNMLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtTQUN0QixDQUFDO0lBQ04sQ0FBQztJQUVEOzs7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