"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const lexer_1 = require("../lexer");
const parser_1 = require("../parser");
const CC = __importStar(require("./Chunk"));
/** * Parses `Tokens` into chunks of tokens, excluding conditional compilation directives. */
class Parser {
    constructor() {
        this.events = new events_1.EventEmitter();
    }
    /**
     * Parses an array of tokens into an array of "chunks" - conditional compilation directives and their
     * associated BrightScript.
     *
     * @param toParse the array of tokens to parse
     * @returns an array of chunks (conditional compilation directives and the associated BrightScript) to be later
     *          executed.
     */
    parse(toParse) {
        let current = 0;
        let tokens = toParse;
        let errors = [];
        /**
         * Emits an error via this parser's `events` property, then throws it.
         * @param err the ParseError to emit then throw
         */
        const emitError = (err) => {
            errors.push(err);
            this.events.emit("err", err);
            throw err;
        };
        try {
            return {
                chunks: nChunks(),
                errors: errors,
            };
        }
        catch (conditionalCompilationError) {
            return {
                chunks: [],
                errors: errors,
            };
        }
        /**
         * Parses tokens to produce an array containing a variable number of heterogeneous chunks.
         * @returns a heterogeneous array of chunks
         */
        function nChunks() {
            let chunks = [];
            while (true) {
                let c = hashConst();
                if (c) {
                    chunks.push(c);
                }
                let maybeEof = eof();
                if (maybeEof) {
                    chunks.push(maybeEof);
                    break;
                }
                else if (!c) {
                    break;
                }
            }
            return chunks;
        }
        /**
         * Parses tokens to produce a "declaration" chunk if possible, otherwise falls back to `hashIf`.
         * @returns a "declaration" chunk if one is detected, otherwise whatever `hashIf` returns
         */
        function hashConst() {
            if (match(lexer_1.Lexeme.HashConst)) {
                let name = advance();
                consume("Expected '=' after #const (name)", lexer_1.Lexeme.Equal);
                let value = advance();
                match(lexer_1.Lexeme.Newline);
                return new CC.Declaration(name, value);
            }
            return hashIf();
        }
        /**
         * Parses tokens to produce an "if" chunk (including "else if" and "else" chunks) if possible,
         * otherwise falls back to `hashError`.
         * @returns an "if" chunk if one is detected, otherwise whatever `hashError` returns
         */
        function hashIf() {
            if (match(lexer_1.Lexeme.HashIf)) {
                let startingLine = previous().location.start.line;
                let elseChunk;
                let ifCondition = advance();
                match(lexer_1.Lexeme.Newline);
                let thenChunk = nChunks();
                let elseIfs = [];
                while (match(lexer_1.Lexeme.HashElseIf)) {
                    let condition = advance();
                    match(lexer_1.Lexeme.Newline);
                    elseIfs.push({
                        condition: condition,
                        thenChunks: nChunks(),
                    });
                }
                if (match(lexer_1.Lexeme.HashElse)) {
                    match(lexer_1.Lexeme.Newline);
                    elseChunk = nChunks();
                }
                consume(`Expected '#else if' to close '#if' conditional compilation statement starting on line ${startingLine}`, lexer_1.Lexeme.HashEndIf);
                match(lexer_1.Lexeme.Newline);
                return new CC.If(ifCondition, thenChunk, elseIfs, elseChunk);
            }
            return hashError();
        }
        /**
         * Parses tokens to produce an "error" chunk (including the associated message) if possible,
         * otherwise falls back to a chunk of plain BrightScript.
         * @returns an "error" chunk if one is detected, otherwise whatever `brightScriptChunk` returns
         */
        function hashError() {
            if (check(lexer_1.Lexeme.HashError)) {
                let hashError = advance();
                let message = advance();
                return new CC.Error(hashError, message.text || "");
            }
            return brightScriptChunk();
        }
        /**
         * Parses tokens to produce a chunk of BrightScript.
         * @returns a chunk of plain BrightScript if any is detected, otherwise `undefined` to indicate
         *          that no non-conditional compilation directives were found.
         */
        function brightScriptChunk() {
            let chunkTokens = [];
            while (!check(lexer_1.Lexeme.HashIf, lexer_1.Lexeme.HashElseIf, lexer_1.Lexeme.HashElse, lexer_1.Lexeme.HashEndIf, lexer_1.Lexeme.HashConst, lexer_1.Lexeme.HashError)) {
                chunkTokens.push(advance());
                if (isAtEnd()) {
                    break;
                }
            }
            if (chunkTokens.length > 0) {
                return new CC.BrightScript(chunkTokens);
            }
            else {
                return undefined;
            }
        }
        function eof() {
            if (isAtEnd()) {
                return new CC.BrightScript([peek()]);
            }
            else {
                return undefined;
            }
        }
        function match(...lexemes) {
            for (let lexeme of lexemes) {
                if (check(lexeme)) {
                    advance();
                    return true;
                }
            }
            return false;
        }
        function consume(message, ...lexemes) {
            let foundLexeme = lexemes
                .map(lexeme => peek().kind === lexeme)
                .reduce((foundAny, foundCurrent) => foundAny || foundCurrent, false);
            if (foundLexeme) {
                return advance();
            }
            return emitError(new parser_1.ParseError(peek(), message));
        }
        function advance() {
            if (!isAtEnd()) {
                current++;
            }
            return previous();
        }
        function check(...lexemes) {
            if (isAtEnd()) {
                return false;
            }
            return lexemes.some(lexeme => peek().kind === lexeme);
        }
        function isAtEnd() {
            return peek().kind === lexer_1.Lexeme.Eof;
        }
        function peek() {
            return tokens[current];
        }
        function previous() {
            return tokens[current - 1];
        }
    }
}
exports.Parser = Parser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3ByZXByb2Nlc3Nvci9QYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbUNBQXNDO0FBRXRDLG9DQUF5QztBQUN6QyxzQ0FBdUM7QUFDdkMsNENBQThCO0FBVTlCLDZGQUE2RjtBQUM3RixNQUFhLE1BQU07SUFBbkI7UUFDYSxXQUFNLEdBQUcsSUFBSSxxQkFBWSxFQUFFLENBQUM7SUFrT3pDLENBQUM7SUFoT0c7Ozs7Ozs7T0FPRztJQUNILEtBQUssQ0FBQyxPQUE2QjtRQUMvQixJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEIsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDO1FBQ3JCLElBQUksTUFBTSxHQUFpQixFQUFFLENBQUM7UUFFOUI7OztXQUdHO1FBQ0gsTUFBTSxTQUFTLEdBQUcsQ0FBQyxHQUFlLEVBQVMsRUFBRTtZQUN6QyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztZQUM3QixNQUFNLEdBQUcsQ0FBQztRQUNkLENBQUMsQ0FBQztRQUVGLElBQUk7WUFDQSxPQUFPO2dCQUNILE1BQU0sRUFBRSxPQUFPLEVBQUU7Z0JBQ2pCLE1BQU0sRUFBRSxNQUFNO2FBQ2pCLENBQUM7U0FDTDtRQUFDLE9BQU8sMkJBQTJCLEVBQUU7WUFDbEMsT0FBTztnQkFDSCxNQUFNLEVBQUUsRUFBRTtnQkFDVixNQUFNLEVBQUUsTUFBTTthQUNqQixDQUFDO1NBQ0w7UUFFRDs7O1dBR0c7UUFDSCxTQUFTLE9BQU87WUFDWixJQUFJLE1BQU0sR0FBZSxFQUFFLENBQUM7WUFFNUIsT0FBTyxJQUFJLEVBQUU7Z0JBQ1QsSUFBSSxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUM7Z0JBQ3BCLElBQUksQ0FBQyxFQUFFO29CQUNI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