"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const util_1 = require("util");
const access = util_1.promisify(fs.access);
const readFile = util_1.promisify(fs.readFile);
/**
 * Attempts to read a `manifest` file, parsing its contents into a map of string to JavaScript
 * number, string, or boolean.
 * @param rootDir the root directory in which a `manifest` file is expected
 * @returns a Promise that resolves to a map of string to JavaScript number, string, or boolean,
 *          representing the manifest file's contents
 */
function getManifest(rootDir) {
    return __awaiter(this, void 0, void 0, function* () {
        let manifestPath = path.join(rootDir, "manifest");
        let contents;
        try {
            contents = yield readFile(manifestPath, "utf-8");
        }
        catch (err) {
            return new Map();
        }
        return parseManifest(contents);
    });
}
exports.getManifest = getManifest;
/**
 * A synchronous version of `getManifest`.
 * @param rootDir the root directory in which a `manifest` file is expected
 * @returns a map of string to JavaScript number, string, or boolean, representing the manifest
 *          file's contents
 */
function getManifestSync(rootDir) {
    let manifestPath = path.join(rootDir, "manifest");
    if (!fs.existsSync(manifestPath)) {
        return new Map();
    }
    let contents = fs.readFileSync(manifestPath, "utf-8");
    return parseManifest(contents);
}
exports.getManifestSync = getManifestSync;
/**
 * Attempts to parse a `manifest` file's contents into a map of string to JavaScript
 * number, string, or boolean.
 * @param contents the text contents of a manifest file.
 * @returns a Promise that resolves to a map of string to JavaScript number, string, or boolean,
 *          representing the manifest file's contents
 */
function parseManifest(contents) {
    let keyValuePairs = contents
        // for each line
        .split("\n")
        // remove leading/trailing whitespace
        .map(line => line.trim())
        // separate keys and values
        .map((line, index) => {
        // skip empty lines and comments
        if (line === "" || line.startsWith("#")) {
            return ["", ""];
        }
        let equals = line.indexOf("=");
        if (equals === -1) {
            throw new Error(`[manifest:${index +
                1}] No '=' detected.  Manifest attributes must be of the form 'key=value'.`);
        }
        return [line.slice(0, equals), line.slice(equals + 1)];
    })
        // keep only non-empty keys and values
        .filter(([key, value]) => key && value)
        // remove leading/trailing whitespace from keys and values
        .map(([key, value]) => [key.trim(), value.trim()])
        // convert value to boolean, integer, or leave as string
        .map(([key, value]) => {
        if (value.toLowerCase() === "true") {
            return [key, true];
        }
        if (value.toLowerCase() === "false") {
            return [key, false];
        }
        let maybeNumber = Number.parseInt(value);
        // if it's not a number, it's just a string
        if (Number.isNaN(maybeNumber)) {
            return [key, value];
        }
        return [key, maybeNumber];
    });
    return new Map(keyValuePairs);
}
exports.parseManifest = parseManifest;
/**
 * Parses a 'manifest' file's `bs_const` property into a map of key to boolean value.
 * @param manifest the internal representation of the 'manifest' file to extract `bs_const` from
 * @returns a map of key to boolean value representing the `bs_const` attribute, or an empty map if
 *          no `bs_const` attribute is found.
 */
function getBsConst(manifest) {
    if (!manifest.has("bs_const")) {
        return new Map();
    }
    let bsConstString = manifest.get("bs_const");
    if (typeof bsConstString !== "string") {
        throw new Error("Invalid bs_const right-hand side.  bs_const must be a string of ';'-separated 'key=value' pairs");
    }
    let keyValuePairs = bsConstString
        // for each key-value pair
        .split(";")
        // ignore empty key-value pairs
        .filter(keyValuePair => !!keyValuePair)
        // separate keys and values
        .map(keyValuePair => {
        let equals = keyValuePair.indexOf("=");
        if (equals === -1) {
            throw new Error(`No '=' detected for key ${keyValuePair}.  bs_const constants must be of the form 'key=value'.`);
        }
        return [keyValuePair.slice(0, equals), keyValuePair.slice(equals + 1)];
    })
        // remove leading/trailing whitespace from keys and values
        .map(([key, value]) => [key.trim(), value.trim()])
        // convert value to boolean or throw
        .map(([key, value]) => {
        if (value.toLowerCase() === "true") {
            return [key, true];
        }
        if (value.toLowerCase() === "false") {
            return [key, false];
        }
        throw new Error(`Invalid value for bs_const key '${key}'.  Values must be either 'true' or 'false'.`);
    });
    return new Map(keyValuePairs);
}
exports.getBsConst = getBsConst;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFuaWZlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcHJlcHJvY2Vzc29yL01hbmlmZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUM3QiwrQkFBaUM7QUFFakMsTUFBTSxNQUFNLEdBQUcsZ0JBQVMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDcEMsTUFBTSxRQUFRLEdBQUcsZ0JBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7QUFReEM7Ozs7OztHQU1HO0FBQ0gsU0FBc0IsV0FBVyxDQUFDLE9BQWU7O1FBQzdDLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRWxELElBQUksUUFBZ0IsQ0FBQztRQUNyQixJQUFJO1lBQ0EsUUFBUSxHQUFHLE1BQU0sUUFBUSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNwRDtRQUFDLE9BQU8sR0FBRyxFQUFFO1lBQ1YsT0FBTyxJQUFJLEdBQUcsRUFBRSxDQUFDO1NBQ3BCO1FBQ0QsT0FBTyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDbkMsQ0FBQztDQUFBO0FBVkQsa0NBVUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxPQUFlO0lBQzNDLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRWxELElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFO1FBQzlCLE9BQU8sSUFBSSxHQUFHLEVBQUUsQ0FBQztLQUNwQjtJQUVELElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RELE9BQU8sYUFBYSxDQUFDLFFBQVEsQ0FB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