"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Lexeme_1 = require("./Lexeme");
const ReservedWords_1 = require("./ReservedWords");
const Error_1 = require("../Error");
const Characters_1 = require("./Characters");
const brsTypes_1 = require("../brsTypes");
class Lexer {
    constructor() {
        /** Allows consumers to observe errors as they're detected. */
        this.events = new events_1.EventEmitter();
    }
    /**
     * A convenience function, equivalent to `new Lexer().scan(toScan)`, that converts a string
     * containing BrightScript code to an array of `Token` objects that will later be used to build
     * an abstract syntax tree.
     *
     * @param toScan the BrightScript code to convert into tokens
     * @param filename the name of the file to be scanned
     * @returns an object containing an array of `errors` and an array of `tokens` to be passed to a parser.
     */
    static scan(toScan, filename = "") {
        return new Lexer().scan(toScan, filename);
    }
    /**
     * Convenience function to subscribe to the `err` events emitted by `lexer.events`.
     * @param errorHandler the function to call for every Lexer error emitted after subscribing
     * @returns an object with a `dispose` function, used to unsubscribe from errors
     */
    onError(errorHandler) {
        this.events.on("err", errorHandler);
        return {
            dispose: () => {
                this.events.removeListener("err", errorHandler);
            },
        };
    }
    /**
     * Convenience function to subscribe to a single `err` event emitted by `lexer.events`.
     * @param errorHandler the function to call for the first Lexer error emitted after subscribing
     */
    onErrorOnce(errorHandler) {
        this.events.once("err", errorHandler);
    }
    /**
     * Converts a string containing BrightScript code to an array of `Token` objects that will
     * later be used to build an abstract syntax tree.
     *
     * @param toScan the BrightScript code to convert into tokens
     * @param filename the name of the file to be scanned
     * @returns an object containing an array of `errors` and an array of `tokens` to be passed to a parser.
     */
    scan(toScan, filename) {
        /** The zero-indexed position at which the token under consideration begins. */
        let start = 0;
        /** The zero-indexed position being examined for the token under consideration. */
        let current = 0;
        /** The one-indexed line number being parsed. */
        let line = 1;
        /** The zero-indexed column number being parsed. */
        let column = 0;
        /** The BrightScript code being converted to an array of `Token`s. */
        let source = toScan;
        /** The tokens produced from `source`. */
        let tokens = [];
        /** The errors produced from `source.` */
        let errors = [];
        const addError = (err) => {
            errors.push(err);
            this.events.emit("err", err);
        };
        while (!isAtEnd()) {
            start = current;
            scanToken();
        }
        tokens.push({
            kind: Lexeme_1.Lexeme.Eof,
            isReserved: false,
            text: "\0",
            location: {
                start: {
                    line: line,
                    column: column,
                },
                end: {
                    line: line,
                    column: column + 1,
                },
                file: filename,
            },
        });
        return { tokens, errors };
        /**
         * Determines whether or not the lexer as reached the end of its input.
         * @returns `true` if the lexer has read to (or past) the end of its input, otherwise `false`.
         */
        function isAtEnd() {
            return current >= source.length;
        }
        /**
         * Reads a non-deterministic number of characters from `source`, produces a `Token`, and adds it to
         * the `tokens` array.
         *
         * Accepts and returns nothing, because it's side-effect driven.
         */
        function scanToken() {
            let c = advance();
            switch (c.toLowerCase()) {
                case "(":
                    addToken(Lexeme_1.Lexeme.LeftParen);
                    break;
                case ")":
                    addToken(Lexeme_1.Lexeme.RightParen);
                    break;
                case "{":
                    addToken(Lexeme_1.Lexeme.LeftBrace);
                    break;
                case "}":
                    addToken(Lexeme_1.Lexeme.RightBrace);
                    break;
                case "[":
                    addToken(Lexeme_1.Lexeme.LeftSquare);
                    break;
                case "]":
                    addToken(Lexeme_1.Lexeme.RightSquare);
                    break;
                case ",":
                    addToken(Lexeme_1.Lexeme.Comma);
                    break;
                case ".":
                    // this might be a float/double literal, because decimals without a leading 0
                    // are allowed
                    if (Characters_1.isDecimalDigit(peek())) {
                        decimalNumber(true);
                    }
                    else {
                        addToken(Lexeme_1.Lexeme.Dot);
                    }
                    break;
                case "+":
                    switch (peek()) {
                        case "=":
                            advance();
                            addToken(Lexeme_1.Lexeme.PlusEqual);
                            break;
                        case "+":
                            advance();
                            addToken(Lexeme_1.Lexeme.PlusPlus);
                            break;
                        default:
                            addToken(Lexeme_1.Lexeme.Plus);
                            break;
                    }
                    break;
                case "-":
                    switch (peek()) {
                        case "=":
                            advance();
                            addToken(Lexeme_1.Lexeme.MinusEqual);
                            break;
                        case "-":
                            advance();
                            addToken(Lexeme_1.Lexeme.MinusMinus);
                            break;
                        default:
                            addToken(Lexeme_1.Lexeme.Minus);
                            break;
                    }
                    break;
                case "*":
                    switch (peek()) {
                        case "=":
                            advance();
                            addToken(Lexeme_1.Lexeme.StarEqual);
                            break;
                        default:
                            addToken(Lexeme_1.Lexeme.Star);
                            break;
                    }
                    break;
                case "/":
                    switch (peek()) {
                        case "=":
                            advance();
                            addToken(Lexeme_1.Lexeme.SlashEqual);
                            break;
                        default:
                            addToken(Lexeme_1.Lexeme.Slash);
                            break;
                    }
                    break;
                case "^":
                    addToken(Lexeme_1.Lexeme.Caret);
                    break;
                case "\\":
                    switch (peek()) {
                        case "=":
                            advance();
                            addToken(Lexeme_1.Lexeme.BackslashEqual);
                            break;
                        default:
                            addToken(Lexeme_1.Lexeme.Backslash);
                            break;
                    }
                    break;
                case "=":
                    addToken(Lexeme_1.Lexeme.Equal);
                    break;
                case ":":
                    addToken(Lexeme_1.Lexeme.Colon);
                    break;
                case ";":
                    addToken(Lexeme_1.Lexeme.Semicolon);
                    break;
                case "?":
                    addToken(Lexeme_1.Lexeme.Print);
                    break;
                case "<":
                    switch (peek()) {
                        case "=":
                            advance();
                            addToken(Lexeme_1.Lexeme.LessEqual);
                            break;
                        case "<":
                            advance();
                            switch (peek()) {
                                case "=":
                                    advance();
                                    addToken(Lexeme_1.Lexeme.LeftShiftEqual);
                                    break;
                                default:
                                    addToken(Lexeme_1.Lexeme.LeftShift);
                                    break;
                            }
                            break;
                        case ">":
                            advance();
                            addToken(Lexeme_1.Lexeme.LessGreater);
                            break;
                        default:
                            addToken(Lexeme_1.Lexeme.Less);
                            break;
                    }
                    break;
                case ">":
                    switch (peek()) {
                        case "=":
                            advance();
                            addToken(Lexeme_1.Lexeme.GreaterEqual);
                            break;
                        case ">":
                            advance();
                            switch (peek()) {
                                case "=":
                                    advance();
                                    addToken(Lexeme_1.Lexeme.RightShiftEqual);
                                    break;
                                default:
                                    addToken(Lexeme_1.Lexeme.RightShift);
                                    break;
                            }
                            break;
                        default:
                            addToken(Lexeme_1.Lexeme.Greater);
                            break;
                    }
                    break;
                case "'":
                    // BrightScript doesn't have block comments; only line
                    while (peek() !== "\n" && !isAtEnd()) {
                        advance();
                    }
                    break;
                case " ":
                case "\r":
                case "\t":
                    // ignore whitespace; indentation isn't signficant in BrightScript
                    break;
                case "\n":
                    // consecutive newlines aren't significant, because they're just blank lines
                    // so only add blank lines when they're not consecutive
                    let previous = lastToken();
                    if (previous && previous.kind !== Lexeme_1.Lexeme.Newline) {
                        addToken(Lexeme_1.Lexeme.Newline);
                    }
                    // but always advance the line counter
                    line++;
                    // and always reset the column counter
                    column = 0;
                    break;
                case '"':
                    string();
                    break;
                case "#":
                    preProcessedConditional();
                    break;
                default:
                    if (Characters_1.isDecimalDigit(c)) {
                        decimalNumber(false);
                    }
                    else if (c === "&" && peek().toLowerCase() === "h") {
                        advance(); // move past 'h'
                        hexadecimalNumber();
                    }
                    else if (Characters_1.isAlpha(c)) {
                        identifier();
                    }
                    else {
                        addError(new Error_1.BrsError(`Unexpected character '${c}'`, locationOf(c)));
                    }
                    break;
            }
        }
        /**
         * Reads and returns the next character from `string` while **moving the current position forward**.
         * @returns the new "current" character.
         */
        function advance() {
            current++;
            column++;
            return source.charAt(current - 1);
        }
        /**
         * Determines whether the "current" character matches an `expected` character and advances the
         * "current" character if it does.
         *
         * @param expected a single-character string to test for.
         * @returns `true` if `expected` is strictly equal to the current character, otherwise `false`
         *          (including if we've reached the end of the input).
         */
        function match(expected) {
            if (expected.length > 1) {
                throw new Error(`Lexer#match expects a single character; received '${expected}'`);
            }
            if (isAtEnd()) {
                return false;
            }
            if (source.charAt(current) !== expected) {
                return false;
            }
            current++;
            return true;
        }
        /**
         * Returns the character at position `current` or a null character if we've reached the end of
         * input.
         *
         * @returns the current character if we haven't reached the end of input, otherwise a null
         *          character.
         */
        function peek() {
            if (isAtEnd()) {
                return "\0";
            }
            return source.charAt(current);
        }
        /**
         * Returns the character after position `current`, or a null character if we've reached the end of
         * input.
         *
         * @returns the character after the current one if we haven't reached the end of input, otherwise a
         *          null character.
         */
        function peekNext() {
            if (current + 1 > source.length) {
                return "\0";
            }
            return source.charAt(current + 1);
        }
        /**
         * Reads characters within a string literal, advancing through escaped characters to the
         * terminating `"`, and adds the produced token to the `tokens` array. Creates a `BrsError` if the
         * string is terminated by a newline or the end of input.
         */
        function string() {
            while (!isAtEnd()) {
                if (peek() === '"') {
                    if (peekNext() === '"') {
                        // skip over two consecutive `"` characters to handle escaped `"` literals
                        advance();
                    }
                    else {
                        // otherwise the string has ended
                        break;
                    }
                }
                if (peekNext() === "\n") {
                    // BrightScript doesn't support multi-line strings
                    addError(new Error_1.BrsError("Unterminated string at end of line", locationOf(source.slice(start, current))));
                    return;
                }
                advance();
            }
            if (isAtEnd()) {
                // terminating a string with EOF is also not allowed
                addError(new Error_1.BrsError("Unterminated string at end of file", locationOf(source.slice(start, current))));
                return;
            }
            // move past the closing `"`
            advance();
            // trim the surrounding quotes, and replace the double-" literal with a single
            let value = source.slice(start + 1, current - 1).replace(/""/g, '"');
            addToken(Lexeme_1.Lexeme.String, new brsTypes_1.BrsString(value));
        }
        /**
         * Reads characters within a base-10 number literal, advancing through fractional and
         * exponential portions as well as trailing type identifiers, and adds the produced token
         * to the `tokens` array. Also responsible for BrightScript's integer literal vs. float
         * literal rules.
         * @param hasSeenDecimal `true` if decimal point has already been found, otherwise `false`
         *
         * @see https://sdkdocs.roku.com/display/sdkdoc/Expressions%2C+Variables%2C+and+Types#Expressions,Variables,andTypes-NumericLiterals
         */
        function decimalNumber(hasSeenDecimal) {
            let containsDecimal = hasSeenDecimal;
            while (Characters_1.isDecimalDigit(peek())) {
                advance();
            }
            // look for a fractional portion
            if (!hasSeenDecimal && peek() === ".") {
                containsDecimal = true;
                // consume the "." parse the fractional part
                advance();
                // read the remaining digits
                while (Characters_1.isDecimalDigit(peek())) {
                    advance();
                }
            }
            let asString = source.slice(start, current);
            let numberOfDigits = containsDecimal ? asString.length - 1 : asString.length;
            let designator = peek().toLowerCase();
            if (numberOfDigits >= 10 && designator !== "&") {
                // numeric literals over 10 digits with no type designator are implicitly Doubles
                addToken(Lexeme_1.Lexeme.Double, brsTypes_1.Double.fromString(asString));
                return;
            }
            else if (designator === "#") {
                // numeric literals ending with "#" are forced to Doubles
                advance();
                asString = source.slice(start, current);
                addToken(Lexeme_1.Lexeme.Double, brsTypes_1.Double.fromString(asString));
                return;
            }
            else if (designator === "d") {
                // literals that use "D" as the exponent are also automatic Doubles
                // consume the "D"
                advance();
                // exponents are optionally signed
                if (peek() === "+" || peek() === "-") {
                    advance();
                }
                // consume the exponent
                while (Characters_1.isDecimalDigit(peek())) {
                    advance();
                }
                // replace the exponential marker with a JavaScript-friendly "e"
                asString = source.slice(start, current).replace(/[dD]/, "e");
                addToken(Lexeme_1.Lexeme.Double, brsTypes_1.Double.fromString(asString));
                return;
            }
            if (designator === "!") {
                // numeric literals ending with "!" are forced to Floats
                advance();
                asString = source.slice(start, current);
                addToken(Lexeme_1.Lexeme.Float, brsTypes_1.Float.fromString(asString));
                return;
            }
            else if (designator === "e") {
                // literals that use "E" as the exponent are also automatic Floats
                // consume the "E"
                advance();
                // exponents are optionally signed
                if (peek() === "+" || peek() === "-") {
                    advance();
                }
                // consume the exponent
                while (Characters_1.isDecimalDigit(peek())) {
                    advance();
                }
                asString = source.slice(start, current);
                addToken(Lexeme_1.Lexeme.Float, brsTypes_1.Float.fromString(asString));
                return;
            }
            else if (containsDecimal) {
                // anything with a decimal but without matching Double rules is a Float
                addToken(Lexeme_1.Lexeme.Float, brsTypes_1.Float.fromString(asString));
                return;
            }
            if (designator === "&") {
                // numeric literals ending with "&" are forced to LongIntegers
                asString = source.slice(start, current);
                advance();
                addToken(Lexeme_1.Lexeme.LongInteger, brsTypes_1.Int64.fromString(asString));
                return;
            }
            else {
                // otherwise, it's a regular integer
                addToken(Lexeme_1.Lexeme.Integer, brsTypes_1.Int32.fromString(asString));
                return;
            }
        }
        /**
         * Reads characters within a base-16 number literal, advancing through trailing type
         * identifiers, and adds the produced token to the `tokens` array. Also responsible for
         * BrightScript's integer literal vs. long-integer literal rules _for hex literals only_.
         *
         * @see https://sdkdocs.roku.com/display/sdkdoc/Expressions%2C+Variables%2C+and+Types#Expressions,Variables,andTypes-NumericLiterals
         */
        function hexadecimalNumber() {
            while (Characters_1.isHexDigit(peek())) {
                advance();
            }
            // fractional hex literals aren't valid
            if (peek() === "." && Characters_1.isHexDigit(peekNext())) {
                advance(); // consume the "."
                addError(new Error_1.BrsError("Fractional hex literals are not supported", locationOf(source.slice(start, current))));
                return;
            }
            if (peek() === "&") {
                // literals ending with "&" are forced to LongIntegers
                advance();
                let asString = source.slice(start, current);
                addToken(Lexeme_1.Lexeme.LongInteger, brsTypes_1.Int64.fromString(asString));
            }
            else {
                let asString = source.slice(start, current);
                addToken(Lexeme_1.Lexeme.Integer, brsTypes_1.Int32.fromString(asString));
            }
        }
        /**
         * Reads characters within an identifier, advancing through alphanumeric characters. Adds the
         * produced token to the `tokens` array.
         */
        function identifier() {
            while (Characters_1.isAlphaNumeric(peek())) {
                advance();
            }
            let text = source.slice(start, current).toLowerCase();
            // some identifiers can be split into two words, so check the "next" word and see what we get
            if ((text === "end" || text === "else" || text === "exit" || text === "for") &&
                (peek() === " " || peek() === "\t")) {
                let endOfFirstWord = {
                    position: current,
                    column: column,
                };
                // skip past any whitespace
                let whitespace = "";
                while (peek() === " " || peek() === "\t") {
                    //keep the whitespace so we can replace it later
                    whitespace += peek();
                    advance();
                }
                while (Characters_1.isAlphaNumeric(peek())) {
                    advance();
                } // read the next word
                let twoWords = source.slice(start, current);
                //replace all of the whitespace with a single space character so we can properly match keyword token types
                twoWords = twoWords.replace(whitespace, " ");
                let maybeTokenType = ReservedWords_1.KeyWords[twoWords.toLowerCase()];
                if (maybeTokenType) {
                    addToken(maybeTokenType);
                    return;
                }
                else {
                    // reset if the last word and the current word didn't form a multi-word Lexeme
                    current = endOfFirstWord.position;
                    column = endOfFirstWord.column;
                }
            }
            // look for a type designator character ($ % ! # &). vars may have them, but functions
            // may not. Let the parser figure that part out.
            let nextChar = peek();
            if (["$", "%", "!", "#", "&"].includes(nextChar)) {
                text += nextChar;
                advance();
            }
            let tokenType = ReservedWords_1.KeyWords[text.toLowerCase()] || Lexeme_1.Lexeme.Identifier;
            if (tokenType === ReservedWords_1.KeyWords.rem) {
                // The 'rem' keyword can be used to indicate comments as well, so
                // consume the rest of the line, but don't add the token; it's not
                // particularly useful.
                while (peek() !== "\n" && !isAtEnd()) {
                    advance();
                }
            }
            else {
                addToken(tokenType);
            }
        }
        /**
         * Reads characters within an identifier with a leading '#', typically reserved for conditional
         * compilation. Adds the produced token to the `tokens` array.
         */
        function preProcessedConditional() {
            advance(); // advance past the leading #
            while (Characters_1.isAlphaNumeric(peek())) {
                advance();
            }
            let text = source.slice(start, current).toLowerCase();
            // some identifiers can be split into two words, so check the "next" word and see what we get
            if ((text === "#end" || text === "#else") && peek() === " ") {
                let endOfFirstWord = current;
                advance(); // skip past the space
                while (Characters_1.isAlphaNumeric(peek())) {
                    advance();
                } // read the next word
                let twoWords = source.slice(start, current);
                switch (twoWords.replace(/ {2,}/g, " ")) {
                    case "#else if":
                        addToken(Lexeme_1.Lexeme.HashElseIf);
                        return;
                    case "#end if":
                        addToken(Lexeme_1.Lexeme.HashEndIf);
                        return;
                }
                // reset if the last word and the current word didn't form a multi-word Lexeme
                current = endOfFirstWord;
            }
            switch (text) {
                case "#if":
                    addToken(Lexeme_1.Lexeme.HashIf);
                    return;
                case "#else":
                    addToken(Lexeme_1.Lexeme.HashElse);
                    return;
                case "#elseif":
                    addToken(Lexeme_1.Lexeme.HashElseIf);
                    return;
                case "#endif":
                    addToken(Lexeme_1.Lexeme.HashEndIf);
                    return;
                case "#const":
                    addToken(Lexeme_1.Lexeme.HashConst);
                    return;
                case "#error":
                    addToken(Lexeme_1.Lexeme.HashError);
                    // #error must be followed by a message; scan it separately to preserve whitespace
                    start = current;
                    while (!isAtEnd() && peek() !== "\n") {
                        advance();
                    }
                    // grab all text since we found #error as one token
                    addToken(Lexeme_1.Lexeme.HashErrorMessage);
                    // consume the trailing newline here; it's not semantically significant
                    match("\n");
                    start = current;
                    return;
                default:
                    addError(new Error_1.BrsError(`Found unexpected conditional-compilation string '${text}'`, locationOf(source.slice(start, current))));
            }
        }
        /**
         * Retrieves the token that was most recently added.
         * @returns the most recently added token.
         */
        function lastToken() {
            return tokens[tokens.length - 1];
        }
        /**
         * Creates a `Token` and adds it to the `tokens` array.
         * @param kind the type of token to produce.
         * @param literal an optional literal value to include in the token.
         */
        function addToken(kind, literal) {
            let withWhitespace = source.slice(start, current);
            let text = withWhitespace.trimLeft() || withWhitespace;
            tokens.push({
                kind: kind,
                text: text,
                isReserved: ReservedWords_1.ReservedWords.has(text.toLowerCase()),
                literal: literal,
                location: locationOf(text),
            });
        }
        /**
         * Creates a `TokenLocation` at the lexer's current position for the provided `text`.
         * @param text the text to create a location for
         * @returns the location of `text` as a `TokenLocation`
         */
        function locationOf(text) {
            return {
                start: {
                    line: line,
                    column: column - text.length,
                },
                end: {
                    line: line,
                    column: Math.max(column - text.length + 1, column),
                },
                file: filename,
            };
        }
    }
}
exports.Lexer = Lexer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGV4ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGV4ZXIvTGV4ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBc0M7QUFFdEMscUNBQWtDO0FBRWxDLG1EQUEwRDtBQUMxRCxvQ0FBb0M7QUFDcEMsNkNBQW1GO0FBRW5GLDBDQUE4RTtBQVU5RSxNQUFhLEtBQUs7SUFBbEI7UUFDSSw4REFBOEQ7UUFDckQsV0FBTSxHQUFHLElBQUkscUJBQVksRUFBRSxDQUFDO0lBb3ZCekMsQ0FBQztJQWx2Qkc7Ozs7Ozs7O09BUUc7SUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQWMsRUFBRSxXQUFtQixFQUFFO1FBQzdDLE9BQU8sSUFBSSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksT0FBTyxDQUFDLFlBQXFDO1FBQ2hELElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNwQyxPQUFPO1lBQ0gsT0FBTyxFQUFFLEdBQUcsRUFBRTtnQkFDVixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDcEQsQ0FBQztTQUNKLENBQUM7SUFDTixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksV0FBVyxDQUFDLFlBQXFDO1FBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLElBQUksQ0FBQyxNQUFjLEVBQUUsUUFBZ0I7UUFDeEMsK0VBQStFO1FBQy9FLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNkLGtGQUFrRjtRQUNsRixJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEIsZ0RBQWdEO1FBQ2hELElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNiLG1EQUFtRDtRQUNuRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFFZixxRUFBcUU7UUFDckUsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRXBCLHlDQUF5QztRQUN6QyxJQUFJLE1BQU0sR0FBWSxFQUFFLENBQUM7UUFFekIseUNBQXlDO1FBQ3pDLElBQUksTUFBTSxHQUFlLEVBQUUsQ0FBQztRQUU1QixNQUFNLFFBQVEsR0FBRyxDQUFDLEdBQWEsRUFBRSxFQUFFO1lBQy9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLENBQUMsQ0FBQztRQUVGLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUNmLEtBQUssR0FBRyxPQUFPLENBQUM7WUFDaEIsU0FBUyxFQUFFLENBQUM7U0FDZjtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDUixJQUFJLEVBQUUsZUFBTSxDQUFDLEdBQUc7WUFDaEIsVUFBVSxFQUFFLEtBQUs7WUFDakIsSUFBSSxFQUFFLElBQUk7WUFDVixRQUFRLEVBQUU7Z0JBQ04sS0FBSyxFQUFFO29CQUNILElBQUksRUFBRSxJQUFJO29CQUNWLE1BQU0sRUFBRSxNQUFNO2lCQUNqQjtnQkFDRCxHQUFHLEVBQUU7b0JBQ0QsSUFBSSxFQUFFLElBQUk7b0JBQ1YsTUFBTSxFQUFFLE1BQU0sR0FBRyxDQUFDO2lCQUNyQjtnQkFDRCxJQUFJLEVBQUUsUUFBUTthQUNqQjtTQUNKLENBQUMsQ0FBQztRQUVILE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUM7UUFFMUI7OztXQUdHO1FBQ0gsU0FBUyxPQUFPO1lBQ1osT0FBTyxPQUFPLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNwQyxDQUFDO1FBRUQ7Ozs7O1dBS0c7UUFDSCxTQUFTLFNBQVM7WUFDZCxJQUFJLENBQUMsR0FBRyxPQUFPLEVBQUUsQ0FBQztZQUNsQixRQUFRLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDckIsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzNCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQzVCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzNCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQzVCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQzVCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQzdCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3ZCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLDZFQUE2RTtvQkFDN0UsY0FBYztvQkFDZCxJQUFJLDJCQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRTt3QkFDeEIsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO3FCQUN2Qjt5QkFBTTt3QkFDSCxRQUFRLENBQUMsZUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUN4QjtvQkFDRCxNQUFNO2dCQUNWLEtBQUssR0FBRztvQkFDSixRQUFRLElBQUksRUFBRSxFQUFFO3dCQUNaLEtBQUssR0FBRzs0QkFDSixPQUFPLEVBQUUsQ0FBQzs0QkFDVixRQUFRLENBQUMsZUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzRCQUMzQixNQUFNO3dCQUNWLEtBQUssR0FBRzs0QkFDSixPQUFPLEVBQUUsQ0FBQzs0QkFDVixRQUFRLENBQUMsZUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUMxQixNQUFNO3dCQUNWOzRCQUNJLFFBQVEsQ0FBQyxlQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7NEJBQ3RCLE1BQU07cUJBQ2I7b0JBQ0QsTUFBTTtnQkFDVixLQUFLLEdBQUc7b0JBQ0osUUFBUSxJQUFJLEVBQUUsRUFBRTt3QkFDWixLQUFLLEdBQUc7NEJBQ0osT0FBTyxFQUFFLENBQUM7NEJBQ1YsUUFBUSxDQUFDLGVBQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQzs0QkFDNUIsTUFBTTt3QkFDVixLQUFLLEdBQUc7NEJBQ0osT0FBTyxFQUFFLENBQUM7NEJBQ1YsUUFBUSxDQUFDLGVBQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQzs0QkFDNUIsTUFBTTt3QkFDVjs0QkFDSSxRQUFRLENBQUMsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUN2QixNQUFNO3FCQUNiO29CQUNELE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsSUFBSSxFQUFFLEVBQUU7d0JBQ1osS0FBSyxHQUFHOzRCQUNKLE9BQU8sRUFBRSxDQUFDOzRCQUNWLFFBQVEsQ0FBQyxlQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7NEJBQzNCLE1BQU07d0JBQ1Y7NEJBQ0ksUUFBUSxDQUFDLGVBQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs0QkFDdEIsTUFBTTtxQkFDYjtvQkFDRCxNQUFNO2dCQUNWLEtBQUssR0FBRztvQkFDSixRQUFRLElBQUksRUFBRSxFQUFFO3dCQUNaLEtBQUssR0FBRzs0QkFDSixPQUFPLEVBQUUsQ0FBQzs0QkFDVixRQUFRLENBQUMsZUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDOzRCQUM1QixNQUFNO3dCQUNWOzRCQUNJLFFBQVEsQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7NEJBQ3ZCLE1BQU07cUJBQ2I7b0JBQ0QsTUFBTTtnQkFDVixLQUFLLEdBQUc7b0JBQ0osUUFBUSxDQUFDLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDdkIsTUFBTTtnQkFDVixLQUFLLElBQUk7b0JBQ0wsUUFBUSxJQUFJLEVBQUUsRUFBRTt3QkFDWixLQUFLLEdBQUc7NEJBQ0osT0FBTyxFQUFFLENBQUM7NEJBQ1YsUUFBUSxDQUFDLGVBQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQzs0QkFDaEMsTUFBTTt3QkFDVjs0QkFDSSxRQUFRLENBQUMsZUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzRCQUMzQixNQUFNO3FCQUNiO29CQUNELE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3ZCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3ZCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzNCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3ZCLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLFFBQVEsSUFBSSxFQUFFLEVBQUU7d0JBQ1osS0FBSyxHQUFHOzRCQUNKLE9BQU8sRUFBRSxDQUFDOzRCQUNWLFFBQVEsQ0FBQyxlQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7NEJBQzNCLE1BQU07d0JBQ1YsS0FBSyxHQUFHOzRCQUNKLE9BQU8sRUFBRSxDQUFDOzRCQUNWLFFBQVEsSUFBSSxFQUFFLEVBQUU7Z0NBQ1osS0FBSyxHQUFHO29DQUNKLE9BQU8sRUFBRSxDQUFDO29DQUNWLFFBQVEsQ0FBQyxlQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7b0NBQ2hDLE1BQU07Z0NBQ1Y7b0NBQ0ksUUFBUSxDQUFDLGVBQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztvQ0FDM0IsTUFBTTs2QkFDYjs0QkFDRCxNQUFNO3dCQUNWLEtBQUssR0FBRzs0QkFDSixPQUFPLEVBQUUsQ0FBQzs0QkFDVixRQUFRLENBQUMsZUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzRCQUM3QixNQUFNO3dCQUNWOzRCQUNJLFFBQVEsQ0FBQyxlQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7NEJBQ3RCLE1BQU07cUJBQ2I7b0JBQ0QsTUFBTTtnQkFDVixLQUFLLEdBQUc7b0JBQ0osUUFBUSxJQUFJLEVBQUUsRUFBRTt3QkFDWixLQUFLLEdBQUc7NEJBQ0osT0FBTyxFQUFFLENBQUM7NEJBQ1YsUUFBUSxDQUFDLGVBQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQzs0QkFDOUIsTUFBTTt3QkFDVixLQUFLLEdBQUc7NEJBQ0osT0FBTyxFQUFFLENBQUM7NEJBQ1YsUUFBUSxJQUFJLEVBQUUsRUFBRTtnQ0FDWixLQUFLLEdBQUc7b0NBQ0osT0FBTyxFQUFFLENBQUM7b0NBQ1YsUUFBUSxDQUFDLGVBQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztvQ0FDakMsTUFBTTtnQ0FDVjtvQ0FDSSxRQUFRLENBQUMsZUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO29DQUM1QixNQUFNOzZCQUNiOzRCQUNELE1BQU07d0JBQ1Y7NEJBQ0ksUUFBUSxDQUFDLGVBQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQzs0QkFDekIsTUFBTTtxQkFDYjtvQkFDRCxNQUFNO2dCQUNWLEtBQUssR0FBRztvQkFDSixzREFBc0Q7b0JBQ3RELE9BQU8sSUFBSSxFQUFFLEtBQUssSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUU7d0JBQ2xDLE9BQU8sRUFBRSxDQUFDO3FCQUNiO29CQUNELE1BQU07Z0JBQ1YsS0FBSyxHQUFHLENBQUM7Z0JBQ1QsS0FBSyxJQUFJLENBQUM7Z0JBQ1YsS0FBSyxJQUFJO29CQUNMLGtFQUFrRTtvQkFDbEUsTUFBTTtnQkFDVixLQUFLLElBQUk7b0JBQ0wsNEVBQTRFO29CQUM1RSx1REFBdUQ7b0JBQ3ZELElBQUksUUFBUSxHQUFHLFNBQVMsRUFBRSxDQUFDO29CQUMzQixJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGVBQU0sQ0FBQyxPQUFPLEVBQUU7d0JBQzlDLFFBQVEsQ0FBQyxlQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQzVCO29CQUNELHNDQUFzQztvQkFDdEMsSUFBSSxFQUFFLENBQUM7b0JBQ1Asc0NBQXNDO29CQUN0QyxNQUFNLEdBQUcsQ0FBQyxDQUFDO29CQUNYLE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLE1BQU0sRUFBRSxDQUFDO29CQUNULE1BQU07Z0JBQ1YsS0FBSyxHQUFHO29CQUNKLHVCQUF1QixFQUFFLENBQUM7b0JBQzFCLE1BQU07Z0JBQ1Y7b0JBQ0ksSUFBSSwyQkFBYyxDQUFDLENBQUMsQ0FBQyxFQUFFO3dCQUNuQixhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7cUJBQ3hCO3lCQUFNLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsS0FBSyxHQUFHLEVBQUU7d0JBQ2xELE9BQU8sRUFBRSxDQUFDLENBQUMsZ0JBQWdCO3dCQUMzQixpQkFBaUIsRUFBRSxDQUFDO3FCQUN2Qjt5QkFBTSxJQUFJLG9CQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7d0JBQ25CLFVBQVUsRUFBRSxDQUFDO3FCQUNoQjt5QkFBTTt3QkFDSCxRQUFRLENBQUMsSUFBSSxnQkFBUSxDQUFDLHlCQUF5QixDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN4RTtvQkFDRCxNQUFNO2FBQ2I7UUFDTCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0gsU0FBUyxPQUFPO1lBQ1osT0FBTyxFQUFFLENBQUM7WUFDVixNQUFNLEVBQUUsQ0FBQztZQUNULE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEMsQ0FBQztRQUVEOzs7Ozs7O1dBT0c7UUFDSCxTQUFTLEtBQUssQ0FBQyxRQUFnQjtZQUMzQixJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxRQUFRLEdBQUcsQ0FBQyxDQUFDO2FBQ3JGO1lBRUQsSUFBSSxPQUFPLEVBQUUsRUFBRTtnQkFDWCxPQUFPLEtBQUssQ0FBQzthQUNoQjtZQUNELElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxRQUFRLEVBQUU7Z0JBQ3JDLE9BQU8sS0FBSyxDQUFDO2FBQ2hCO1lBRUQsT0FBTyxFQUFFLENBQUM7WUFDVixPQUFPLElBQUksQ0FBQztRQUNoQixDQUFDO1FBRUQ7Ozs7OztXQU1HO1FBQ0gsU0FBUyxJQUFJO1lBQ1QsSUFBSSxPQUFPLEVBQUUsRUFBRTtnQkFDWCxPQUFPLElBQUksQ0FBQzthQUNmO1lBQ0QsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLENBQUM7UUFFRDs7Ozs7O1dBTUc7UUFDSCxTQUFTLFFBQVE7WUFDYixJQUFJLE9BQU8sR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRTtnQkFDN0IsT0FBTyxJQUFJLENBQUM7YUFDZjtZQUNELE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEMsQ0FBQztRQUVEOzs7O1dBSUc7UUFDSCxTQUFTLE1BQU07WUFDWCxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ2YsSUFBSSxJQUFJLEVBQUUsS0FBSyxHQUFHLEVBQUU7b0JBQ2hCLElBQUksUUFBUSxFQUFFLEtBQUssR0FBRyxFQUFFO3dCQUNwQiwwRUFBMEU7d0JBQzFFLE9BQU8sRUFBRSxDQUFDO3FCQUNiO3lCQUFNO3dCQUNILGlDQUFpQzt3QkFDakMsTUFBTTtxQkFDVDtpQkFDSjtnQkFFRCxJQUFJLFFBQVEsRUFBRSxLQUFLLElBQUksRUFBRTtvQkFDckIsa0RBQWtEO29CQUNsRCxRQUFRLENBQ0osSUFBSSxnQkFBUSxDQUNSLG9DQUFvQyxFQUNwQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FDM0MsQ0FDSixDQUFDO29CQUNGLE9BQU87aUJBQ1Y7Z0JBRUQsT0FBTyxFQUFFLENBQUM7YUFDYjtZQUVELElBQUksT0FBTyxFQUFFLEVBQUU7Z0JBQ1gsb0RBQW9EO2dCQUNwRCxRQUFRLENBQ0osSUFBSSxnQkFBUSxDQUNSLG9DQUFvQyxFQUNwQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FDM0MsQ0FDSixDQUFDO2dCQUNGLE9BQU87YUFDVjtZQUVELDRCQUE0QjtZQUM1QixPQUFPLEVBQUUsQ0FBQztZQUVWLDhFQUE4RTtZQUM5RSxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDckUsUUFBUSxDQUFDLGVBQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxvQkFBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEQsQ0FBQztRQUVEOzs7Ozs7OztXQVFHO1FBQ0gsU0FBUyxhQUFhLENBQUMsY0FBdUI7WUFDMUMsSUFBSSxlQUFlLEdBQUcsY0FBYyxDQUFDO1lBQ3JDLE9BQU8sMkJBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFO2dCQUMzQixPQUFPLEVBQUUsQ0FBQzthQUNiO1lBRUQsZ0NBQWdDO1lBQ2hDLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxFQUFFLEtBQUssR0FBRyxFQUFFO2dCQUNuQyxlQUFlLEdBQUcsSUFBSSxDQUFDO2dCQUV2Qiw0Q0FBNEM7Z0JBQzVDLE9BQU8sRUFBRSxDQUFDO2dCQUVWLDRCQUE0QjtnQkFDNUIsT0FBTywyQkFBYyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUU7b0JBQzNCLE9BQU8sRUFBRSxDQUFDO2lCQUNiO2FBQ0o7WUFFRCxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM1QyxJQUFJLGNBQWMsR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBQzdFLElBQUksVUFBVSxHQUFHLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBRXRDLElBQUksY0FBYyxJQUFJLEVBQUUsSUFBSSxVQUFVLEtBQUssR0FBRyxFQUFFO2dCQUM1QyxpRkFBaUY7Z0JBQ2pGLFFBQVEsQ0FBQyxlQUFNLENBQUMsTUFBTSxFQUFFLGlCQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JELE9BQU87YUFDVjtpQkFBTSxJQUFJLFVBQVUsS0FBSyxHQUFHLEVBQUU7Z0JBQzNCLHlEQUF5RDtnQkFDekQsT0FBTyxFQUFFLENBQUM7Z0JBQ1YsUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUN4QyxRQUFRLENBQUMsZUFBTSxDQUFDLE1BQU0sRUFBRSxpQkFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxPQUFPO2FBQ1Y7aUJBQU0sSUFBSSxVQUFVLEtBQUssR0FBRyxFQUFFO2dCQUMzQixtRUFBbUU7Z0JBRW5FLGtCQUFrQjtnQkFDbEIsT0FBTyxFQUFFLENBQUM7Z0JBRVYsa0NBQWtDO2dCQUNsQyxJQUFJLElBQUksRUFBRSxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUUsS0FBSyxHQUFHLEVBQUU7b0JBQ2xDLE9BQU8sRUFBRSxDQUFDO2lCQUNiO2dCQUVELHVCQUF1QjtnQkFDdkIsT0FBTywyQkFBYyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUU7b0JBQzNCLE9BQU8sRUFBRSxDQUFDO2lCQUNiO2dCQUVELGdFQUFnRTtnQkFDaEUsUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQzdELFFBQVEsQ0FBQyxlQUFNLENBQUMsTUFBTSxFQUFFLGlCQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JELE9BQU87YUFDVjtZQUVELElBQUksVUFBVSxLQUFLLEdBQUcsRUFBRTtnQkFDcEIsd0RBQXdEO2dCQUN4RCxPQUFPLEVBQUUsQ0FBQztnQkFDVixRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ3hDLFFBQVEsQ0FBQyxlQUFNLENBQUMsS0FBSyxFQUFFLGdCQUFLLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQ25ELE9BQU87YUFDVjtpQkFBTSxJQUFJLFVBQVUsS0FBSyxHQUFHLEVBQUU7Z0JBQzNCLGtFQUFrRTtnQkFFbEUsa0JBQWtCO2dCQUNsQixPQUFPLEVBQUUsQ0FBQztnQkFFVixrQ0FBa0M7Z0JBQ2xDLElBQUksSUFBSSxFQUFFLEtBQUssR0FBRyxJQUFJLElBQUksRUFBRSxLQUFLLEdBQUcsRUFBRTtvQkFDbEMsT0FBTyxFQUFFLENBQUM7aUJBQ2I7Z0JBRUQsdUJBQXVCO2dCQUN2QixPQUFPLDJCQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRTtvQkFDM0IsT0FBTyxFQUFFLENBQUM7aUJBQ2I7Z0JBRUQsUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUN4QyxRQUFRLENBQUMsZUFBTSxDQUFDLEtBQUssRUFBRSxnQkFBSyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUNuRCxPQUFPO2FBQ1Y7aUJBQU0sSUFBSSxlQUFlLEVBQUU7Z0JBQ3hCLHVFQUF1RTtnQkFDdkUsUUFBUSxDQUFDLGVBQU0sQ0FBQyxLQUFLLEVBQUUsZ0JBQUssQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDbkQsT0FBTzthQUNWO1lBRUQsSUFBSSxVQUFVLEtBQUssR0FBRyxFQUFFO2dCQUNwQiw4REFBOEQ7Z0JBQzlELFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDeEMsT0FBTyxFQUFFLENBQUM7Z0JBQ1YsUUFBUSxDQUFDLGVBQU0sQ0FBQyxXQUFXLEVBQUUsZ0JBQUssQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDekQsT0FBTzthQUNWO2lCQUFNO2dCQUNILG9DQUFvQztnQkFDcEMsUUFBUSxDQUFDLGVBQU0sQ0FBQyxPQUFPLEVBQUUsZ0JBQUssQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDckQsT0FBTzthQUNWO1FBQ0wsQ0FBQztRQUVEOzs7Ozs7V0FNRztRQUNILFNBQVMsaUJBQWlCO1lBQ3RCLE9BQU8sdUJBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFO2dCQUN2QixPQUFPLEVBQUUsQ0FBQzthQUNiO1lBRUQsdUNBQXVDO1lBQ3ZDLElBQUksSUFBSSxFQUFFLEtBQUssR0FBRyxJQUFJLHVCQUFVLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRTtnQkFDMUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxrQkFBa0I7Z0JBQzdCLFFBQVEsQ0FDSixJQUFJLGdCQUFRLENBQ1IsMkNBQTJDLEVBQzNDLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUMzQyxDQUNKLENBQUM7Z0JBQ0YsT0FBTzthQUNWO1lBRUQsSUFBSSxJQUFJLEVBQUUsS0FBSyxHQUFHLEVBQUU7Z0JBQ2hCLHNEQUFzRDtnQkFDdEQsT0FBTyxFQUFFLENBQUM7Z0JBQ1YsSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQzVDLFFBQVEsQ0FBQyxlQUFNLENBQUMsV0FBVyxFQUFFLGdCQUFLLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7YUFDNUQ7aUJBQU07Z0JBQ0gsSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQzVDLFFBQVEsQ0FBQyxlQUFNLENBQUMsT0FBTyxFQUFFLGdCQUFLLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7YUFDeEQ7UUFDTCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0gsU0FBUyxVQUFVO1lBQ2YsT0FBTywyQkFBYyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUU7Z0JBQzNCLE9BQU8sRUFBRSxDQUFDO2FBQ2I7WUFFRCxJQUFJLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUV0RCw2RkFBNkY7WUFDN0YsSUFDSSxDQUFDLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxLQUFLLENBQUM7Z0JBQ3hFLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxJQUFJLElBQUksRUFBRSxLQUFLLElBQUksQ0FBQyxFQUNyQztnQkFDRSxJQUFJLGNBQWMsR0FBRztvQkFDakIsUUFBUSxFQUFFLE9BQU87b0JBQ2pCLE1BQU0sRUFBRSxNQUFNO2lCQUNqQixDQUFDO2dCQUVGLDJCQUEyQjtnQkFDM0IsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO2dCQUNwQixPQUFPLElBQUksRUFBRSxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUUsS0FBSyxJQUFJLEVBQUU7b0JBQ3RDLGdEQUFnRDtvQkFDaEQsVUFBVSxJQUFJLElBQUksRUFBRSxDQUFDO29CQUNyQixPQUFPLEVBQUUsQ0FBQztpQkFDYjtnQkFDRCxPQUFPLDJCQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRTtvQkFDM0IsT0FBTyxFQUFFLENBQUM7aUJBQ2IsQ0FBQyxxQkFBcUI7Z0JBRXZCLElBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUM1QywwR0FBMEc7Z0JBQzFHLFFBQVEsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxjQUFjLEdBQUcsd0JBQVEsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztnQkFDdEQsSUFBSSxjQUFjLEVBQUU7b0JBQ2hCLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFDekIsT0FBTztpQkFDVjtxQkFBTTtvQkFDSCw4RUFBOEU7b0JBQzlFLE9BQU8sR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDO29CQUNsQyxNQUFNLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztpQkFDbEM7YUFDSjtZQUVELHNGQUFzRjtZQUN0RixnREFBZ0Q7WUFDaEQsSUFBSSxRQUFRLEdBQUcsSUFBSSxFQUFFLENBQUM7WUFDdEIsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzlDLElBQUksSUFBSSxRQUFRLENBQUM7Z0JBQ2pCLE9BQU8sRUFBRSxDQUFDO2FBQ2I7WUFFRCxJQUFJLFNBQVMsR0FBRyx3QkFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLGVBQU0sQ0FBQyxVQUFVLENBQUM7WUFDbEUsSUFBSSxTQUFTLEtBQUssd0JBQVEsQ0FBQyxHQUFHLEVBQUU7Z0JBQzVCLGlFQUFpRTtnQkFDakUsa0VBQWtFO2dCQUNsRSx1QkFBdUI7Z0JBQ3ZCLE9BQU8sSUFBSSxFQUFFLEtBQUssSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQ2xDLE9BQU8sRUFBRSxDQUFDO2lCQUNiO2FBQ0o7aUJBQU07Z0JBQ0gsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ3ZCO1FBQ0wsQ0FBQztRQUVEOzs7V0FHRztRQUNILFNBQVMsdUJBQXVCO1lBQzVCLE9BQU8sRUFBRSxDQUFDLENBQUMsNkJBQTZCO1lBQ3hDLE9BQU8sMkJBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFO2dCQUMzQixPQUFPLEVBQUUsQ0FBQzthQUNiO1lBRUQsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7WUFFdEQsNkZBQTZGO1lBQzdGLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxPQUFPLENBQUMsSUFBSSxJQUFJLEVBQUUsS0FBSyxHQUFHLEVBQUU7Z0JBQ3pELElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQztnQkFFN0IsT0FBTyxFQUFFLENBQUMsQ0FBQyxzQkFBc0I7Z0JBQ2pDLE9BQU8sMkJBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFO29CQUMzQixPQUFPLEVBQUUsQ0FBQztpQkFDYixDQUFDLHFCQUFxQjtnQkFFdkIsSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQzVDLFFBQVEsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLEVBQUU7b0JBQ3JDLEtBQUssVUFBVTt3QkFDWCxRQUFRLENBQUMsZUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO3dCQUM1QixPQUFPO29CQUNYLEtBQUssU0FBUzt3QkFDVixRQUFRLENBQUMsZUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO3dCQUMzQixPQUFPO2lCQUNkO2dCQUVELDhFQUE4RTtnQkFDOUUsT0FBTyxHQUFHLGNBQWMsQ0FBQzthQUM1QjtZQUVELFFBQVEsSUFBSSxFQUFFO2dCQUNWLEtBQUssS0FBSztvQkFDTixRQUFRLENBQUMsZUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUN4QixPQUFPO2dCQUNYLEtBQUssT0FBTztvQkFDUixRQUFRLENBQUMsZUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMxQixPQUFPO2dCQUNYLEtBQUssU0FBUztvQkFDVixRQUFRLENBQUMsZUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUM1QixPQUFPO2dCQUNYLEtBQUssUUFBUTtvQkFDVCxRQUFRLENBQUMsZUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUMzQixPQUFPO2dCQUNYLEtBQUssUUFBUTtvQkFDVCxRQUFRLENBQUMsZUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUMzQixPQUFPO2dCQUNYLEtBQUssUUFBUTtvQkFDVCxRQUFRLENBQUMsZUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUUzQixrRkFBa0Y7b0JBQ2xGLEtBQUssR0FBRyxPQUFPLENBQUM7b0JBQ2hCLE9BQU8sQ0FBQyxPQUFPLEVBQUUsSUFBSSxJQUFJLEVBQUUsS0FBSyxJQUFJLEVBQUU7d0JBQ2xDLE9BQU8sRUFBRSxDQUFDO3FCQUNiO29CQUVELG1EQUFtRDtvQkFDbkQsUUFBUSxDQUFDLGVBQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO29CQUVsQyx1RUFBdUU7b0JBQ3ZFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFFWixLQUFLLEdBQUcsT0FBTyxDQUFDO29CQUNoQixPQUFPO2dCQUNYO29CQUNJLFFBQVEsQ0FDSixJQUFJLGdCQUFRLENBQ1Isb0RBQW9ELElBQUksR0FBRyxFQUMzRCxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FDM0MsQ0FDSixDQUFDO2FBQ1Q7UUFDTCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0gsU0FBUyxTQUFTO1lBQ2QsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBRUQ7Ozs7V0FJRztRQUNILFNBQVMsUUFBUSxDQUFDLElBQVksRUFBRSxPQUFpQjtZQUM3QyxJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNsRCxJQUFJLElBQUksR0FBRyxjQUFjLENBQUMsUUFBUSxFQUFFLElBQUksY0FBYyxDQUFDO1lBQ3ZELE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ1IsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsVUFBVSxFQUFFLDZCQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDakQsT0FBTyxFQUFFLE9BQU87Z0JBQ2hCLFFBQVEsRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDO2FBQzdCLENBQUMsQ0FBQztRQUNQLENBQUM7UUFFRDs7OztXQUlHO1FBQ0gsU0FBUyxVQUFVLENBQUMsSUFBWTtZQUM1QixPQUFPO2dCQUNILEtBQUssRUFBRTtvQkFDSCxJQUFJLEVBQUUsSUFBSTtvQkFDVixNQUFNLEVBQUUsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNO2lCQUMvQjtnQkFDRCxHQUFHLEVBQUU7b0JBQ0QsSUFBSSxFQUFFLElBQUk7b0JBQ1YsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sQ0FBQztpQkFDckQ7Z0JBQ0QsSUFBSSxFQUFFLFFBQVE7YUFDakIsQ0FBQztRQUNOLENBQUM7SUFDTCxDQUFDO0NBQ0o7QUF0dkJELHNCQXN2QkMifQ==