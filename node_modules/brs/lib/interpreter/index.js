"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const brsTypes_1 = require("../brsTypes");
const lexer_1 = require("../lexer");
const Token_1 = require("../lexer/Token");
const parser_1 = require("../parser");
const Error_1 = require("../Error");
const StdLib = __importStar(require("../stdlib"));
const Environment_1 = require("./Environment");
const OutputProxy_1 = require("./OutputProxy");
const BrsFunction_1 = require("./BrsFunction");
const RoAssociativeArray_1 = require("../brsTypes/components/RoAssociativeArray");
const memory_fs_1 = __importDefault(require("memory-fs"));
const BrsComponent_1 = require("../brsTypes/components/BrsComponent");
const Boxing_1 = require("../brsTypes/Boxing");
/** The default set of execution options.  Includes the `stdout`/`stderr` pair from the process that invoked `brs`. */
exports.defaultExecutionOptions = {
    root: process.cwd(),
    stdout: process.stdout,
    stderr: process.stderr,
};
class Interpreter {
    /**
     * Creates a new Interpreter, including any global properties and functions.
     * @param options configuration for the execution, including the streams to use for `stdout` and
     *                `stderr` and the base directory for path resolution
     */
    constructor(options = exports.defaultExecutionOptions) {
        this._environment = new Environment_1.Environment();
        this.temporaryVolume = new memory_fs_1.default();
        /** Allows consumers to observe errors as they're detected. */
        this.events = new events_1.EventEmitter();
        /** The set of errors detected from executing an AST. */
        this.errors = [];
        this.stdout = new OutputProxy_1.OutputProxy(options.stdout);
        this.stderr = new OutputProxy_1.OutputProxy(options.stderr);
        this.options = options;
        Object.keys(StdLib)
            .map(name => StdLib[name])
            .filter(func => func instanceof brsTypes_1.Callable)
            .filter((func) => {
            if (!func.name) {
                throw new Error("Unnamed standard library function detected!");
            }
            return !!func.name;
        })
            .forEach((func) => this._environment.define(Environment_1.Scope.Global, func.name || "", func));
    }
    get environment() {
        return this._environment;
    }
    /**
     * Convenience function to subscribe to the `err` events emitted by `interpreter.events`.
     * @param errorHandler the function to call for every runtime error emitted after subscribing
     * @returns an object with a `dispose` function, used to unsubscribe from errors
     */
    onError(errorHandler) {
        this.events.on("err", errorHandler);
        return {
            dispose: () => {
                this.events.removeListener("err", errorHandler);
            },
        };
    }
    /**
     * Convenience function to subscribe to a single `err` event emitted by `interpreter.events`.
     * @param errorHandler the function to call for the first runtime error emitted after subscribing
     */
    onErrorOnce(errorHandler) {
        this.events.once("err", errorHandler);
    }
    /**
     * Temporarily sets an interpreter's environment to the provided one, then
     * passes the sub-interpreter to the provided JavaScript function. Always
     * reverts the current interpreter's environment to its original value.
     * @param func the JavaScript function to execute with the sub interpreter.
     */
    inSubEnv(func) {
        let originalEnvironment = this._environment;
        let newEnv = this._environment.createSubEnvironment();
        try {
            this._environment = newEnv;
            return func(this);
        }
        catch (err) {
            if (!(err instanceof Error_1.BrsError)) {
                console.error("Runtime error encountered in BRS implementation: ", err);
            }
            throw err;
        }
        finally {
            this._environment = originalEnvironment;
        }
    }
    exec(statements, ...args) {
        let results = statements.map(statement => this.execute(statement));
        try {
            let mainVariable = new parser_1.Expr.Variable({
                kind: lexer_1.Lexeme.Identifier,
                text: "main",
                isReserved: false,
                location: {
                    start: {
                        line: -1,
                        column: -1,
                    },
                    end: {
                        line: -1,
                        column: -1,
                    },
                    file: "(internal)",
                },
            });
            let maybeMain = this.visitVariable(mainVariable);
            if (maybeMain.kind === brsTypes_1.ValueKind.Callable) {
                results = [
                    this.visitCall(new parser_1.Expr.Call(mainVariable, mainVariable.name, args.map(arg => new parser_1.Expr.Literal(arg, mainVariable.location)))),
                ];
            }
        }
        catch (err) {
            if (err instanceof parser_1.Stmt.ReturnValue) {
                results = [err.value || brsTypes_1.BrsInvalid.Instance];
            }
            else {
                throw err;
            }
        }
        finally {
            return results;
        }
    }
    visitNamedFunction(statement) {
        if (statement.name.isReserved) {
            return this.addError(new Error_1.BrsError(`Cannot create a named function with reserved name '${statement.name.text}'`, statement.name.location));
        }
        if (this.environment.has(statement.name, [Environment_1.Scope.Module])) {
            // TODO: Figure out how to determine where the original version was declared
            // Maybe `Environment.define` records the location along with the value?
            return this.addError(new Error_1.BrsError(`Attempting to declare function '${statement.name.text}', but ` +
                `a property of that name already exists in this scope.`, statement.name.location));
        }
        this.environment.define(Environment_1.Scope.Module, statement.name.text, BrsFunction_1.toCallable(statement.func, statement.name.text));
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitReturn(statement) {
        if (!statement.value) {
            throw new parser_1.Stmt.ReturnValue(statement.tokens.return.location);
        }
        let toReturn = this.evaluate(statement.value);
        throw new parser_1.Stmt.ReturnValue(statement.tokens.return.location, toReturn);
    }
    visitExpression(statement) {
        return this.evaluate(statement.expression);
    }
    visitPrint(statement) {
        // the `tab` function is only in-scope while executing print statements
        this.environment.define(Environment_1.Scope.Function, "Tab", StdLib.Tab);
        statement.expressions.forEach((printable, index) => {
            if (Token_1.isToken(printable)) {
                switch (printable.kind) {
                    case lexer_1.Lexeme.Comma:
                        this.stdout.write(" ".repeat(16 - (this.stdout.position() % 16)));
                        break;
                    case lexer_1.Lexeme.Semicolon:
                        if (index === statement.expressions.length - 1) {
                            // Don't write an extra space for trailing `;` in print lists.
                            // They're used to suppress trailing newlines in `print` statements
                            break;
                        }
                        this.stdout.write(" ");
                        break;
                    default:
                        this.addError(new Error_1.BrsError(`Found unexpected print separator '${printable.text}'`, printable.location));
                }
            }
            else {
                this.stdout.write(this.evaluate(printable).toString());
            }
        });
        let lastExpression = statement.expressions[statement.expressions.length - 1];
        if (!Token_1.isToken(lastExpression) || lastExpression.kind !== lexer_1.Lexeme.Semicolon) {
            this.stdout.write("\n");
        }
        // `tab` is only in-scope when executing print statements, so remove it before we leave
        this.environment.remove("Tab");
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitAssignment(statement) {
        if (statement.name.isReserved) {
            this.addError(new Error_1.BrsError(`Cannot assign a value to reserved name '${statement.name.text}'`, statement.name.location));
            return brsTypes_1.BrsInvalid.Instance;
        }
        let value = this.evaluate(statement.value);
        let name = statement.name.text;
        const typeDesignators = {
            $: brsTypes_1.ValueKind.String,
            "%": brsTypes_1.ValueKind.Int32,
            "!": brsTypes_1.ValueKind.Float,
            "#": brsTypes_1.ValueKind.Double,
            "&": brsTypes_1.ValueKind.Int64,
        };
        let requiredType = typeDesignators[name.charAt(name.length - 1)];
        if (requiredType && requiredType !== value.kind) {
            return this.addError(new Error_1.TypeMismatch({
                message: `Attempting to assign incorrect value to statically-typed variable '${name}'`,
                left: {
                    type: requiredType,
                    location: statement.name.location,
                },
                right: {
                    type: value,
                    location: statement.value.location,
                },
            }));
        }
        this.environment.define(Environment_1.Scope.Function, statement.name.text, value);
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitBinary(expression) {
        let lexeme = expression.token.kind;
        let left = this.evaluate(expression.left);
        let right = brsTypes_1.BrsInvalid.Instance;
        if (lexeme !== lexer_1.Lexeme.And && lexeme !== lexer_1.Lexeme.Or) {
            // don't evaluate right-hand-side of boolean expressions, to preserve short-circuiting
            // behavior found in other languages. e.g. `foo() && bar()` won't execute `bar()` if
            // `foo()` returns `false`.
            right = this.evaluate(expression.right);
        }
        /**
         * Determines whether or not the provided pair of values are allowed to be compared to each other.
         * @param left the left-hand side of a comparison operator
         * @param operator the operator to use when comparing `left` and `right`
         * @param right the right-hand side of a comparison operator
         * @returns `true` if `left` and `right` are allowed to be compared to each other with `operator`,
         *          otherwise `false`.
         */
        function canCheckEquality(left, operator, right) {
            if (left.kind === brsTypes_1.ValueKind.Invalid || right.kind === brsTypes_1.ValueKind.Invalid) {
                // anything can be checked for *equality* with `invalid`, but greater than / less than comparisons
                // are type mismatches
                return operator === lexer_1.Lexeme.Equal || operator === lexer_1.Lexeme.LessGreater;
            }
            return ((left.kind < brsTypes_1.ValueKind.Dynamic || Boxing_1.isUnboxable(left)) &&
                (right.kind < brsTypes_1.ValueKind.Dynamic || Boxing_1.isUnboxable(right)));
        }
        switch (lexeme) {
            case lexer_1.Lexeme.Minus:
            case lexer_1.Lexeme.MinusEqual:
                if (brsTypes_1.isBrsNumber(left) && brsTypes_1.isBrsNumber(right)) {
                    return left.subtract(right);
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to subtract non-numeric values.",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            case lexer_1.Lexeme.Star:
            case lexer_1.Lexeme.StarEqual:
                if (brsTypes_1.isBrsNumber(left) && brsTypes_1.isBrsNumber(right)) {
                    return left.multiply(right);
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to multiply non-numeric values.",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            case lexer_1.Lexeme.Caret:
                if (brsTypes_1.isBrsNumber(left) && brsTypes_1.isBrsNumber(right)) {
                    return left.pow(right);
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to exponentiate non-numeric values.",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            case lexer_1.Lexeme.Slash:
            case lexer_1.Lexeme.SlashEqual:
                if (brsTypes_1.isBrsNumber(left) && brsTypes_1.isBrsNumber(right)) {
                    return left.divide(right);
                }
                return this.addError(new Error_1.TypeMismatch({
                    message: "Attempting to dividie non-numeric values.",
                    left: {
                        type: left,
                        location: expression.left.location,
                    },
                    right: {
                        type: right,
                        location: expression.right.location,
                    },
                }));
            case lexer_1.Lexeme.Mod:
                if (brsTypes_1.isBrsNumber(left) && brsTypes_1.isBrsNumber(right)) {
                    return left.modulo(right);
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to modulo non-numeric values.",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            case lexer_1.Lexeme.Backslash:
            case lexer_1.Lexeme.BackslashEqual:
                if (brsTypes_1.isBrsNumber(left) && brsTypes_1.isBrsNumber(right)) {
                    return left.intDivide(right);
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to integer-divide non-numeric values.",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            case lexer_1.Lexeme.Plus:
            case lexer_1.Lexeme.PlusEqual:
                if (brsTypes_1.isBrsNumber(left) && brsTypes_1.isBrsNumber(right)) {
                    return left.add(right);
                }
                else if (brsTypes_1.isBrsString(left) && brsTypes_1.isBrsString(right)) {
                    return left.concat(right);
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to add non-homogeneous values.",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            case lexer_1.Lexeme.Greater:
                if ((brsTypes_1.isBrsNumber(left) || brsTypes_1.isBrsString(left)) &&
                    (brsTypes_1.isBrsNumber(right) || brsTypes_1.isBrsString(right))) {
                    return left.greaterThan(right);
                }
                return this.addError(new Error_1.TypeMismatch({
                    message: "Attempting to compare non-primitive values.",
                    left: {
                        type: left,
                        location: expression.left.location,
                    },
                    right: {
                        type: right,
                        location: expression.right.location,
                    },
                }));
            case lexer_1.Lexeme.GreaterEqual:
                if ((brsTypes_1.isBrsNumber(left) || brsTypes_1.isBrsString(left)) &&
                    (brsTypes_1.isBrsNumber(right) || brsTypes_1.isBrsString(right))) {
                    return left.greaterThan(right).or(left.equalTo(right));
                }
                else if (canCheckEquality(left, lexeme, right)) {
                    return left.equalTo(right);
                }
                return this.addError(new Error_1.TypeMismatch({
                    message: "Attempting to compare non-primitive values.",
                    left: {
                        type: left,
                        location: expression.left.location,
                    },
                    right: {
                        type: right,
                        location: expression.right.location,
                    },
                }));
            case lexer_1.Lexeme.Less:
                if ((brsTypes_1.isBrsNumber(left) || brsTypes_1.isBrsString(left)) &&
                    (brsTypes_1.isBrsNumber(right) || brsTypes_1.isBrsString(right))) {
                    return left.lessThan(right);
                }
                return this.addError(new Error_1.TypeMismatch({
                    message: "Attempting to compare non-primitive values.",
                    left: {
                        type: left,
                        location: expression.left.location,
                    },
                    right: {
                        type: right,
                        location: expression.right.location,
                    },
                }));
            case lexer_1.Lexeme.LessEqual:
                if ((brsTypes_1.isBrsNumber(left) || brsTypes_1.isBrsString(left)) &&
                    (brsTypes_1.isBrsNumber(right) || brsTypes_1.isBrsString(right))) {
                    return left.lessThan(right).or(left.equalTo(right));
                }
                else if (canCheckEquality(left, lexeme, right)) {
                    return left.equalTo(right);
                }
                return this.addError(new Error_1.TypeMismatch({
                    message: "Attempting to compare non-primitive values.",
                    left: {
                        type: left,
                        location: expression.left.location,
                    },
                    right: {
                        type: right,
                        location: expression.right.location,
                    },
                }));
            case lexer_1.Lexeme.Equal:
                if (canCheckEquality(left, lexeme, right)) {
                    return left.equalTo(right);
                }
                return this.addError(new Error_1.TypeMismatch({
                    message: "Attempting to compare non-primitive values.",
                    left: {
                        type: left,
                        location: expression.left.location,
                    },
                    right: {
                        type: right,
                        location: expression.right.location,
                    },
                }));
            case lexer_1.Lexeme.LessGreater:
                if (canCheckEquality(left, lexeme, right)) {
                    return left.equalTo(right).not();
                }
                return this.addError(new Error_1.TypeMismatch({
                    message: "Attempting to compare non-primitive values.",
                    left: {
                        type: left,
                        location: expression.left.location,
                    },
                    right: {
                        type: right,
                        location: expression.right.location,
                    },
                }));
            case lexer_1.Lexeme.And:
                if (brsTypes_1.isBrsBoolean(left) && !left.toBoolean()) {
                    // short-circuit ANDs - don't evaluate RHS if LHS is false
                    return brsTypes_1.BrsBoolean.False;
                }
                else if (brsTypes_1.isBrsBoolean(left)) {
                    right = this.evaluate(expression.right);
                    if (brsTypes_1.isBrsBoolean(right)) {
                        return left.and(right);
                    }
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to 'and' boolean with non-boolean value",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
                else if (brsTypes_1.isBrsNumber(left)) {
                    right = this.evaluate(expression.right);
                    if (brsTypes_1.isBrsNumber(right)) {
                        // TODO: support boolean AND with numbers
                        return left.and(right);
                    }
                    // TODO: figure out how to handle 32-bit int AND 64-bit int
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to bitwise 'and' number with non-numberic value",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to 'and' unexpected values",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            case lexer_1.Lexeme.Or:
                if (brsTypes_1.isBrsBoolean(left) && left.toBoolean()) {
                    // short-circuit ORs - don't evaluate RHS if LHS is true
                    return brsTypes_1.BrsBoolean.True;
                }
                else if (brsTypes_1.isBrsBoolean(left)) {
                    right = this.evaluate(expression.right);
                    if (brsTypes_1.isBrsBoolean(right)) {
                        return left.or(right);
                    }
                    else {
                        return this.addError(new Error_1.TypeMismatch({
                            message: "Attempting to 'or' boolean with non-boolean value",
                            left: {
                                type: left,
                                location: expression.left.location,
                            },
                            right: {
                                type: right,
                                location: expression.right.location,
                            },
                        }));
                    }
                }
                else if (brsTypes_1.isBrsNumber(left)) {
                    right = this.evaluate(expression.right);
                    if (brsTypes_1.isBrsNumber(right)) {
                        return left.or(right);
                    }
                    // TODO: figure out how to handle 32-bit int OR 64-bit int
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to bitwise 'or' number with non-numeric expression",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
                else {
                    return this.addError(new Error_1.TypeMismatch({
                        message: "Attempting to 'or' unexpected values",
                        left: {
                            type: left,
                            location: expression.left.location,
                        },
                        right: {
                            type: right,
                            location: expression.right.location,
                        },
                    }));
                }
            default:
                return this.addError(new Error_1.BrsError(`Received unexpected token kind '${expression.token.kind}'`, expression.token.location));
        }
    }
    visitBlock(block) {
        block.statements.forEach(statement => this.execute(statement));
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitExitFor(statement) {
        throw new parser_1.Stmt.ExitForReason(statement.location);
    }
    visitExitWhile(expression) {
        throw new parser_1.Stmt.ExitWhileReason(expression.location);
    }
    visitCall(expression) {
        let functionName = "[anonymous function]";
        // TODO: autobox
        if (expression.callee instanceof parser_1.Expr.Variable ||
            expression.callee instanceof parser_1.Expr.DottedGet) {
            functionName = expression.callee.name.text;
        }
        // evaluate the function to call (it could be the result of another function call)
        const callee = this.evaluate(expression.callee);
        // evaluate all of the arguments as well (they could also be function calls)
        const args = expression.args.map(this.evaluate, this);
        if (!brsTypes_1.isBrsCallable(callee)) {
            return this.addError(new Error_1.BrsError(`'${functionName}' is not a function and cannot be called.`, expression.closingParen.location));
        }
        functionName = callee.getName();
        let satisfiedSignature = callee.getFirstSatisfiedSignature(args);
        if (satisfiedSignature) {
            try {
                let mPointer = this._environment.getM();
                if (expression.callee instanceof parser_1.Expr.DottedGet ||
                    expression.callee instanceof parser_1.Expr.IndexedGet) {
                    let maybeM = this.evaluate(expression.callee.obj);
                    maybeM = Boxing_1.isBoxable(maybeM) ? maybeM.box() : maybeM;
                    if (maybeM.kind === brsTypes_1.ValueKind.Object) {
                        if (maybeM instanceof RoAssociativeArray_1.RoAssociativeArray) {
                            mPointer = maybeM;
                        }
                    }
                    else {
                        return this.addError(new Error_1.BrsError("Attempted to retrieve a function from a primitive value", expression.closingParen.location));
                    }
                }
                return this.inSubEnv(subInterpreter => {
                    subInterpreter.environment.setM(mPointer);
                    return callee.call(this, ...args);
                });
            }
            catch (reason) {
                if (!(reason instanceof parser_1.Stmt.BlockEnd)) {
                    throw new Error("Something terrible happened and we didn't throw a `BlockEnd` instance.");
                }
                let returnedValue = reason.value;
                let returnLocation = reason.location;
                if (returnedValue && satisfiedSignature.signature.returns === brsTypes_1.ValueKind.Void) {
                    this.addError(new parser_1.Stmt.Runtime(`Attempting to return value of non-void type ${brsTypes_1.ValueKind.toString(returnedValue.kind)} ` + `from function ${callee.getName()} with void return type.`, returnLocation));
                }
                if (!returnedValue && satisfiedSignature.signature.returns !== brsTypes_1.ValueKind.Void) {
                    this.addError(new parser_1.Stmt.Runtime(`Attempting to return void value from function ${callee.getName()} with non-void return type.`, returnLocation));
                }
                if (returnedValue &&
                    satisfiedSignature.signature.returns !== brsTypes_1.ValueKind.Dynamic &&
                    satisfiedSignature.signature.returns !== returnedValue.kind) {
                    this.addError(new parser_1.Stmt.Runtime(`Attempting to return value of type ${brsTypes_1.ValueKind.toString(returnedValue.kind)}, ` +
                        `but function ${callee.getName()} declares return value of type ` +
                        brsTypes_1.ValueKind.toString(satisfiedSignature.signature.returns), returnLocation));
                }
                return returnedValue || brsTypes_1.BrsInvalid.Instance;
            }
        }
        else {
            function formatMismatch(mismatchedSignature) {
                let sig = mismatchedSignature.signature;
                let mismatches = mismatchedSignature.mismatches;
                let messageParts = [];
                let args = sig.args
                    .map(a => {
                    let requiredArg = `${a.name.text} as ${brsTypes_1.ValueKind.toString(a.type.kind)}`;
                    if (a.defaultValue) {
                        return `[${requiredArg}]`;
                    }
                    else {
                        return requiredArg;
                    }
                })
                    .join(", ");
                messageParts.push(`function ${functionName}(${args}) as ${brsTypes_1.ValueKind.toString(sig.returns)}:`);
                messageParts.push(...mismatches
                    .map(mm => {
                    switch (mm.reason) {
                        case brsTypes_1.MismatchReason.TooFewArguments:
                            return `* ${functionName} requires at least ${mm.expected} arguments, but received ${mm.received}.`;
                        case brsTypes_1.MismatchReason.TooManyArguments:
                            return `* ${functionName} accepts at most ${mm.expected} arguments, but received ${mm.received}.`;
                        case brsTypes_1.MismatchReason.ArgumentTypeMismatch:
                            return `* Argument '${mm.argName}' must be of type ${mm.expected}, but received ${mm.received}.`;
                    }
                })
                    .map(line => `    ${line}`));
                return messageParts.map(line => `    ${line}`).join("\n");
            }
            let mismatchedSignatures = callee.getAllSignatureMismatches(args);
            let header;
            let messages;
            if (mismatchedSignatures.length === 1) {
                header = `Provided arguments don't match ${functionName}'s signature.`;
                messages = [formatMismatch(mismatchedSignatures[0])];
            }
            else {
                header = `Provided arguments don't match any of ${functionName}'s signatures.`;
                messages = mismatchedSignatures.map(formatMismatch);
            }
            return this.addError(new Error_1.BrsError([header, ...messages].join("\n"), expression.closingParen.location));
        }
    }
    visitDottedGet(expression) {
        let source = this.evaluate(expression.obj);
        if (brsTypes_1.isIterable(source)) {
            try {
                return source.get(new brsTypes_1.BrsString(expression.name.text));
            }
            catch (err) {
                return this.addError(new Error_1.BrsError(err.message, expression.name.location));
            }
        }
        let boxedSource = Boxing_1.isBoxable(source) ? source.box() : source;
        if (boxedSource instanceof BrsComponent_1.BrsComponent) {
            try {
                return boxedSource.getMethod(expression.name.text) || brsTypes_1.BrsInvalid.Instance;
            }
            catch (err) {
                return this.addError(new Error_1.BrsError(err.message, expression.name.location));
            }
        }
        else {
            return this.addError(new Error_1.TypeMismatch({
                message: "Attempting to retrieve property from non-iterable value",
                left: {
                    type: source,
                    location: expression.location,
                },
            }));
        }
    }
    visitIndexedGet(expression) {
        let source = this.evaluate(expression.obj);
        if (!brsTypes_1.isIterable(source)) {
            throw new Error_1.TypeMismatch({
                message: "Attempting to retrieve property from non-iterable value",
                left: {
                    type: source,
                    location: expression.location,
                },
            });
        }
        let index = this.evaluate(expression.index);
        if (!brsTypes_1.isBrsNumber(index) && !brsTypes_1.isBrsString(index)) {
            throw new Error_1.TypeMismatch({
                message: "Attempting to retrieve property from iterable with illegal index type",
                left: {
                    type: source,
                    location: expression.obj.location,
                },
                right: {
                    type: index,
                    location: expression.index.location,
                },
            });
        }
        try {
            return source.get(index);
        }
        catch (err) {
            return this.addError(new Error_1.BrsError(err.message, expression.closingSquare.location));
        }
    }
    visitGrouping(expr) {
        return this.evaluate(expr.expression);
    }
    visitFor(statement) {
        // BrightScript for/to loops evaluate the counter initial value, final value, and increment
        // values *only once*, at the top of the for/to loop.
        this.execute(statement.counterDeclaration);
        const finalValue = this.evaluate(statement.finalValue);
        const increment = this.evaluate(statement.increment);
        const counterName = statement.counterDeclaration.name;
        const step = new parser_1.Stmt.Assignment({ equals: statement.tokens.for }, counterName, new parser_1.Expr.Binary(new parser_1.Expr.Variable(counterName), {
            kind: lexer_1.Lexeme.Plus,
            text: "+",
            isReserved: false,
            location: {
                start: {
                    line: -1,
                    column: -1,
                },
                end: {
                    line: -1,
                    column: -1,
                },
                file: "(internal)",
            },
        }, new parser_1.Expr.Literal(increment, statement.increment.location)));
        let loopExitReason;
        while (this.evaluate(new parser_1.Expr.Variable(counterName))
            .equalTo(finalValue)
            .not()
            .toBoolean()) {
            // execute the block
            try {
                this.execute(statement.body);
            }
            catch (reason) {
                if (reason instanceof parser_1.Stmt.ExitForReason) {
                    loopExitReason = reason;
                    break;
                }
                else {
                    // re-throw returns, runtime errors, etc.
                    throw reason;
                }
            }
            // then increment the counter
            this.execute(step);
        }
        // BrightScript for/to loops execute the body one more time when initial === final
        if (loopExitReason === undefined) {
            this.execute(statement.body);
            // they also increments the counter once more
            this.execute(step);
        }
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitForEach(statement) {
        let target = this.evaluate(statement.target);
        if (!brsTypes_1.isIterable(target)) {
            return this.addError(new Error_1.BrsError(`Attempting to iterate across values of non-iterable type ` +
                brsTypes_1.ValueKind.toString(target.kind), statement.item.location));
        }
        target.getElements().every(element => {
            this.environment.define(Environment_1.Scope.Function, statement.item.text, element);
            // execute the block
            try {
                this.execute(statement.body);
            }
            catch (reason) {
                if (reason instanceof parser_1.Stmt.ExitForReason) {
                    // break out of the loop
                    return false;
                }
                else {
                    // re-throw returns, runtime errors, etc.
                    throw reason;
                }
            }
            // keep looping
            return true;
        });
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitWhile(statement) {
        while (this.evaluate(statement.condition)
            .equalTo(brsTypes_1.BrsBoolean.True)
            .toBoolean()) {
            try {
                this.execute(statement.body);
            }
            catch (reason) {
                if (reason instanceof parser_1.Stmt.ExitWhileReason) {
                    break;
                }
                else {
                    // re-throw returns, runtime errors, etc.
                    throw reason;
                }
            }
        }
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitIf(statement) {
        if (this.evaluate(statement.condition)
            .equalTo(brsTypes_1.BrsBoolean.True)
            .toBoolean()) {
            this.execute(statement.thenBranch);
            return brsTypes_1.BrsInvalid.Instance;
        }
        else {
            for (const elseIf of statement.elseIfs || []) {
                if (this.evaluate(elseIf.condition)
                    .equalTo(brsTypes_1.BrsBoolean.True)
                    .toBoolean()) {
                    this.execute(elseIf.thenBranch);
                    return brsTypes_1.BrsInvalid.Instance;
                }
            }
            if (statement.elseBranch) {
                this.execute(statement.elseBranch);
            }
            return brsTypes_1.BrsInvalid.Instance;
        }
    }
    visitAnonymousFunction(func) {
        return BrsFunction_1.toCallable(func);
    }
    visitLiteral(expression) {
        return expression.value;
    }
    visitArrayLiteral(expression) {
        return new brsTypes_1.RoArray(expression.elements.map(expr => this.evaluate(expr)));
    }
    visitAALiteral(expression) {
        return new RoAssociativeArray_1.RoAssociativeArray(expression.elements.map(member => ({
            name: member.name,
            value: this.evaluate(member.value),
        })));
    }
    visitDottedSet(statement) {
        let source = this.evaluate(statement.obj);
        let value = this.evaluate(statement.value);
        if (!brsTypes_1.isIterable(source)) {
            return this.addError(new Error_1.TypeMismatch({
                message: "Attempting to set property on non-iterable value",
                left: {
                    type: source,
                    location: statement.name.location,
                },
            }));
        }
        try {
            source.set(new brsTypes_1.BrsString(statement.name.text), value);
        }
        catch (err) {
            return this.addError(new Error_1.BrsError(err.message, statement.name.location));
        }
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitIndexedSet(statement) {
        let source = this.evaluate(statement.obj);
        if (!brsTypes_1.isIterable(source)) {
            return this.addError(new Error_1.TypeMismatch({
                message: "Attempting to set property on non-iterable value",
                left: {
                    type: source,
                    location: statement.obj.location,
                },
            }));
        }
        let index = this.evaluate(statement.index);
        if (!brsTypes_1.isBrsNumber(index) && !brsTypes_1.isBrsString(index)) {
            return this.addError(new Error_1.TypeMismatch({
                message: "Attempting to set property on iterable with illegal index type",
                left: {
                    type: source,
                    location: statement.obj.location,
                },
                right: {
                    type: index,
                    location: statement.index.location,
                },
            }));
        }
        let value = this.evaluate(statement.value);
        try {
            source.set(index, value);
        }
        catch (err) {
            return this.addError(new Error_1.BrsError(err.message, statement.closingSquare.location));
        }
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitIncrement(expression) {
        let target = this.evaluate(expression.value);
        if (!brsTypes_1.isBrsNumber(target)) {
            let operation = expression.token.kind === lexer_1.Lexeme.PlusPlus ? "increment" : "decrement";
            return this.addError(new Error_1.BrsError(`Attempting to ${operation} value of non-numeric type ${brsTypes_1.ValueKind.toString(target.kind)}`, expression.location));
        }
        let result;
        if (expression.token.kind === lexer_1.Lexeme.PlusPlus) {
            result = target.add(new brsTypes_1.Int32(1));
        }
        else {
            result = target.subtract(new brsTypes_1.Int32(1));
        }
        if (expression.value instanceof parser_1.Expr.Variable) {
            // store the result of the operation
            this.environment.define(Environment_1.Scope.Function, expression.value.name.text, result);
        }
        else if (expression.value instanceof parser_1.Expr.DottedGet) {
            // immediately execute a dotted "set" statement
            this.execute(new parser_1.Stmt.DottedSet(expression.value.obj, expression.value.name, new parser_1.Expr.Literal(result, expression.location)));
        }
        else if (expression.value instanceof parser_1.Expr.IndexedGet) {
            // immediately execute an indexed "set" statement
            this.execute(new parser_1.Stmt.IndexedSet(expression.value.obj, expression.value.index, new parser_1.Expr.Literal(result, expression.location), expression.value.closingSquare));
        }
        // always return `invalid`, because ++/-- are purely side-effects in BrightScript
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitUnary(expression) {
        let right = this.evaluate(expression.right);
        switch (expression.operator.kind) {
            case lexer_1.Lexeme.Minus:
                if (brsTypes_1.isBrsNumber(right)) {
                    return right.multiply(new brsTypes_1.Int32(-1));
                }
                else {
                    return this.addError(new Error_1.BrsError(`Attempting to negate non-numeric value.
                            value type: ${brsTypes_1.ValueKind.toString(right.kind)}`, expression.operator.location));
                }
            case lexer_1.Lexeme.Not:
                if (brsTypes_1.isBrsBoolean(right)) {
                    return right.not();
                }
                else {
                    return this.addError(new Error_1.BrsError(`Attempting to NOT non-boolean value.
                            value type: ${brsTypes_1.ValueKind.toString(right.kind)}`, expression.operator.location));
                }
        }
        return brsTypes_1.BrsInvalid.Instance;
    }
    visitVariable(expression) {
        try {
            return this.environment.get(expression.name);
        }
        catch (err) {
            if (err instanceof Environment_1.NotFound) {
                return brsTypes_1.Uninitialized.Instance;
            }
            throw err;
        }
    }
    evaluate(expression) {
        return expression.accept(this);
    }
    execute(statement) {
        return statement.accept(this);
    }
    /**
     * Emits an error via this processor's `events` property, then throws it.
     * @param err the ParseError to emit then throw
     */
    addError(err) {
        this.errors.push(err);
        this.events.emit("err", err);
        throw err;
    }
}
exports.Interpreter = Interpreter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJwcmV0ZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsbUNBQXNDO0FBRXRDLDBDQW1CcUI7QUFFckIsb0NBQWtDO0FBQ2xDLDBDQUF5QztBQUN6QyxzQ0FBdUM7QUFDdkMsb0NBQWtEO0FBRWxELGtEQUFvQztBQUVwQywrQ0FBNkQ7QUFDN0QsK0NBQTRDO0FBQzVDLCtDQUEyQztBQUUzQyxrRkFBK0U7QUFDL0UsMERBQXlDO0FBQ3pDLHNFQUFtRTtBQUNuRSwrQ0FBNEQ7QUFXNUQsc0hBQXNIO0FBQ3pHLFFBQUEsdUJBQXVCLEdBQXFCO0lBQ3JELElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxFQUFFO0lBQ25CLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtJQUN0QixNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07Q0FDekIsQ0FBQztBQUVGLE1BQWEsV0FBVztJQXdDcEI7Ozs7T0FJRztJQUNILFlBQVksVUFBNEIsK0JBQXVCO1FBNUN2RCxpQkFBWSxHQUFHLElBQUkseUJBQVcsRUFBRSxDQUFDO1FBS2hDLG9CQUFlLEdBQXFCLElBQUksbUJBQWdCLEVBQUUsQ0FBQztRQUVwRSw4REFBOEQ7UUFDckQsV0FBTSxHQUFHLElBQUkscUJBQVksRUFBRSxDQUFDO1FBRXJDLHdEQUF3RDtRQUN4RCxXQUFNLEdBQTJCLEVBQUUsQ0FBQztRQWtDaEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLHlCQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSx5QkFBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUV2QixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNkLEdBQUcsQ0FBQyxJ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