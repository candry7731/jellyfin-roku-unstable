"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Expr = __importStar(require("./Expression"));
const Stmt = __importStar(require("./Statement"));
const lexer_1 = require("../lexer");
const ParseError_1 = require("./ParseError");
const brsTypes_1 = require("../brsTypes");
/** The set of operators valid for use in assignment statements. */
const assignmentOperators = [
    lexer_1.Lexeme.Equal,
    lexer_1.Lexeme.MinusEqual,
    lexer_1.Lexeme.PlusEqual,
    lexer_1.Lexeme.StarEqual,
    lexer_1.Lexeme.SlashEqual,
    lexer_1.Lexeme.BackslashEqual,
    lexer_1.Lexeme.LeftShiftEqual,
    lexer_1.Lexeme.RightShiftEqual,
];
/** List of Lexemes that are permitted as property names. */
const allowedProperties = [
    lexer_1.Lexeme.And,
    lexer_1.Lexeme.Box,
    lexer_1.Lexeme.CreateObject,
    lexer_1.Lexeme.Dim,
    lexer_1.Lexeme.Else,
    lexer_1.Lexeme.ElseIf,
    lexer_1.Lexeme.End,
    lexer_1.Lexeme.EndFunction,
    lexer_1.Lexeme.EndFor,
    lexer_1.Lexeme.EndIf,
    lexer_1.Lexeme.EndSub,
    lexer_1.Lexeme.EndWhile,
    lexer_1.Lexeme.Eval,
    lexer_1.Lexeme.Exit,
    lexer_1.Lexeme.ExitFor,
    lexer_1.Lexeme.ExitWhile,
    lexer_1.Lexeme.False,
    lexer_1.Lexeme.For,
    lexer_1.Lexeme.ForEach,
    lexer_1.Lexeme.Function,
    lexer_1.Lexeme.GetGlobalAA,
    lexer_1.Lexeme.GetLastRunCompileError,
    lexer_1.Lexeme.GetLastRunRunTimeError,
    lexer_1.Lexeme.Goto,
    lexer_1.Lexeme.If,
    lexer_1.Lexeme.Invalid,
    lexer_1.Lexeme.Let,
    lexer_1.Lexeme.Next,
    lexer_1.Lexeme.Not,
    lexer_1.Lexeme.ObjFun,
    lexer_1.Lexeme.Or,
    lexer_1.Lexeme.Pos,
    lexer_1.Lexeme.Print,
    lexer_1.Lexeme.Rem,
    lexer_1.Lexeme.Return,
    lexer_1.Lexeme.Step,
    lexer_1.Lexeme.Stop,
    lexer_1.Lexeme.Sub,
    lexer_1.Lexeme.Tab,
    lexer_1.Lexeme.To,
    lexer_1.Lexeme.True,
    lexer_1.Lexeme.Type,
    lexer_1.Lexeme.While,
];
/** List of Lexeme that are allowed as local var identifiers. */
const allowedIdentifiers = [lexer_1.Lexeme.EndFor, lexer_1.Lexeme.ExitFor, lexer_1.Lexeme.ForEach];
/**
 * List of string versions of Lexeme that are NOT allowed as local var identifiers.
 * Used to throw more helpful "you can't use a reserved word as an identifier" errors.
 */
const disallowedIdentifiers = new Set([
    lexer_1.Lexeme.And,
    lexer_1.Lexeme.Box,
    lexer_1.Lexeme.CreateObject,
    lexer_1.Lexeme.Dim,
    lexer_1.Lexeme.Else,
    lexer_1.Lexeme.ElseIf,
    lexer_1.Lexeme.End,
    lexer_1.Lexeme.EndFunction,
    lexer_1.Lexeme.EndIf,
    lexer_1.Lexeme.EndSub,
    lexer_1.Lexeme.EndWhile,
    lexer_1.Lexeme.Eval,
    lexer_1.Lexeme.Exit,
    lexer_1.Lexeme.ExitWhile,
    lexer_1.Lexeme.False,
    lexer_1.Lexeme.For,
    lexer_1.Lexeme.Function,
    lexer_1.Lexeme.GetGlobalAA,
    lexer_1.Lexeme.GetLastRunCompileError,
    lexer_1.Lexeme.GetLastRunRunTimeError,
    lexer_1.Lexeme.Goto,
    lexer_1.Lexeme.If,
    lexer_1.Lexeme.Invalid,
    lexer_1.Lexeme.Let,
    lexer_1.Lexeme.Next,
    lexer_1.Lexeme.Not,
    lexer_1.Lexeme.ObjFun,
    lexer_1.Lexeme.Or,
    lexer_1.Lexeme.Pos,
    lexer_1.Lexeme.Print,
    lexer_1.Lexeme.Rem,
    lexer_1.Lexeme.Return,
    lexer_1.Lexeme.Step,
    lexer_1.Lexeme.Sub,
    lexer_1.Lexeme.Tab,
    lexer_1.Lexeme.To,
    lexer_1.Lexeme.True,
    lexer_1.Lexeme.Type,
    lexer_1.Lexeme.While,
].map(x => lexer_1.Lexeme[x].toLowerCase()));
class Parser {
    constructor() {
        /** Allows consumers to observe errors as they're detected. */
        this.events = new events_1.EventEmitter();
    }
    /**
     * A convenience function, equivalent to `new Parser().parse(toParse)`, that parses an array of
     * `Token`s into an abstract syntax tree that can be executed with the `Interpreter`.
     * @param toParse the array of tokens to parse
     * @returns an array of `Statement` objects that together form the abstract syntax tree of the
     *          program
     */
    static parse(toParse) {
        return new Parser().parse(toParse);
    }
    /**
     * Convenience function to subscribe to the `err` events emitted by `parser.events`.
     * @param errorHandler the function to call for every Parser error emitted after subscribing
     * @returns an object with a `dispose` function, used to unsubscribe from errors
     */
    onError(errorHandler) {
        this.events.on("err", errorHandler);
        return {
            dispose: () => {
                this.events.removeListener("err", errorHandler);
            },
        };
    }
    /**
     * Convenience function to subscribe to a single `err` event emitted by `parser.events`.
     * @param errorHandler the function to call for the first Parser error emitted after subscribing
     */
    onErrorOnce(errorHandler) {
        this.events.once("err", errorHandler);
    }
    /**
     * Parses an array of `Token`s into an abstract syntax tree that can be executed with the `Interpreter`.
     * @param toParse the array of tokens to parse
     * @returns an array of `Statement` objects that together form the abstract syntax tree of the
     *          program
     */
    parse(toParse) {
        let current = 0;
        let tokens = toParse;
        //the depth of the calls to function declarations. Helps some checks know if they are at the root or not.
        let functionDeclarationLevel = 0;
        function isAtRootLevel() {
            return functionDeclarationLevel === 0;
        }
        let statements = [];
        let errors = [];
        /**
         * Add an error to the parse results.
         * @param token - the token where the error occurred
         * @param message - the message for this error
         * @returns an error object that can be thrown if the calling code needs to abort parsing
         */
        const addError = (token, message) => {
            let err = new ParseError_1.ParseError(token, message);
            errors.push(err);
            this.events.emit("err", err);
            return err;
        };
        /**
         * Add an error at the given location.
         * @param location
         * @param message
         */
        const addErrorAtLocation = (location, message) => {
            addError({ location: location }, message);
        };
        if (toParse.length === 0) {
            return {
                statements: [],
                errors: [],
            };
        }
        try {
            while (!isAtEnd()) {
                let dec = declaration();
                if (dec) {
                    statements.push(dec);
                }
            }
            return { statements, errors };
        }
        catch (parseError) {
            return {
                statements: [],
                errors: errors,
            };
        }
        /**
         * A simple wrapper around `check` to make tests for a `end` identifier.
         * `end` is a keyword, but not reserved, so associative arrays can have properties
         * called `end`; the parser takes on this task.
         * @returns `true` if the next token is an identifier with text `end`, otherwise `false`
         */
        function checkEnd() {
            return check(lexer_1.Lexeme.Identifier) && peek().text.toLowerCase() === "end";
        }
        function declaration(...additionalTerminators) {
            try {
                // consume any leading newlines
                while (match(lexer_1.Lexeme.Newline))
                    ;
                if (check(lexer_1.Lexeme.Sub, lexer_1.Lexeme.Function)) {
                    return functionDeclaration(false);
                }
                if (checkLibrary()) {
                    return libraryStatement();
                }
                // BrightScript is like python, in that variables can be declared without a `var`,
                // `let`, (...) keyword. As such, we must check the token *after* an identifier to figure
                // out what to do with it.
                if (check(lexer_1.Lexeme.Identifier, ...allowedIdentifiers) &&
                    checkNext(...assignmentOperators)) {
                    return assignment(...additionalTerminators);
                }
                return statement(...additionalTerminators);
            }
            catch (error) {
                synchronize();
                return;
            }
        }
        function functionDeclaration(isAnonymous) {
            try {
                //certain statements need to know if they are contained within a function body
                //so track the depth here
                functionDeclarationLevel++;
                let startingKeyword = peek();
                let isSub = check(lexer_1.Lexeme.Sub);
                let functionType = advance();
                let name;
                let returnType;
                let leftParen;
                let rightParen;
                if (isSub) {
                    returnType = brsTypes_1.ValueKind.Void;
                }
                else {
                    returnType = brsTypes_1.ValueKind.Dynamic;
                }
                if (isAnonymous) {
                    leftParen = consume(`Expected '(' after ${functionType.text}`, lexer_1.Lexeme.LeftParen);
                }
                else {
                    name = consume(`Expected ${functionType.text} name after '${functionType.text}'`, lexer_1.Lexeme.Identifier);
                    leftParen = consume(`Expected '(' after ${functionType.text} name`, lexer_1.Lexeme.LeftParen);
                    //prevent functions from ending with type designators
                    let lastChar = name.text[name.text.length - 1];
                    if (["$", "%", "!", "#", "&"].includes(lastChar)) {
                        //don't throw this error; let the parser continue
                        addError(name, `Function name '${name.text}' cannot end with type designator '${lastChar}'`);
                    }
                }
                let args = [];
                if (!check(lexer_1.Lexeme.RightParen)) {
                    do {
                        if (args.length >= Expr.Call.MaximumArguments) {
                            throw addError(peek(), `Cannot have more than ${Expr.Call.MaximumArguments} arguments`);
                        }
                        args.push(signatureArgument());
                    } while (match(lexer_1.Lexeme.Comma));
                }
                rightParen = advance();
                let maybeAs = peek();
                if (check(lexer_1.Lexeme.Identifier) && maybeAs.text.toLowerCase() === "as") {
                    advance();
                    let typeToken = advance();
                    let typeString = typeToken.text || "";
                    let maybeReturnType = brsTypes_1.ValueKind.fromString(typeString);
                    if (!maybeReturnType) {
                        throw addError(typeToken, `Function return type '${typeString}' is invalid`);
                    }
                    returnType = maybeReturnType;
                }
                args.reduce((haveFoundOptional, arg) => {
                    if (haveFoundOptional && !arg.defaultValue) {
                        throw addError({
                            kind: lexer_1.Lexeme.Identifier,
                            text: arg.name.text,
                            isReserved: lexer_1.ReservedWords.has(arg.name.text),
                            location: arg.location,
                        }, `Argument '${arg.name.text}' has no default value, but comes after arguments with default values`);
                    }
                    return haveFoundOptional || !!arg.defaultValue;
                }, false);
                consume(`Expected newline or ':' after ${functionType.text} signature`, lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon);
                //support ending the function with `end sub` OR `end function`
                let body = block(lexer_1.Lexeme.EndSub, lexer_1.Lexeme.EndFunction);
                if (!body) {
                    throw addError(peek(), `Expected 'end ${functionType.text}' to terminate ${functionType.text} block`);
                }
                // consume 'end sub' or 'end function'
                let endingKeyword = advance();
                let expectedEndKind = isSub ? lexer_1.Lexeme.EndSub : lexer_1.Lexeme.EndFunction;
                //if `function` is ended with `end sub`, or `sub` is ended with `end function`, then
                //add an error but don't hard-fail so the AST can continue more gracefully
                if (endingKeyword.kind !== expectedEndKind) {
                    addError(endingKeyword, `Expected 'end ${functionType.text}' to terminate ${functionType.text} block`);
                }
                let func = new Expr.Function(args, returnType, body, startingKeyword, endingKeyword);
                if (isAnonymous) {
                    return func;
                }
                else {
                    // only consume trailing newlines in the statement context; expressions
                    // expect to handle their own trailing whitespace
                    while (match(lexer_1.Lexeme.Newline))
                        ;
                    return new Stmt.Function(name, func);
                }
            }
            finally {
                functionDeclarationLevel--;
            }
        }
        function signatureArgument() {
            if (!check(lexer_1.Lexeme.Identifier)) {
                throw addError(peek(), `Expected argument name, but received '${peek().text || ""}'`);
            }
            let name = advance();
            let type = brsTypes_1.ValueKind.Dynamic;
            let typeToken;
            let defaultValue;
            // parse argument default value
            if (match(lexer_1.Lexeme.Equal)) {
                // it seems any expression is allowed here -- including ones that operate on other arguments!
                defaultValue = expression();
            }
            let next = peek();
            if (check(lexer_1.Lexeme.Identifier) && next.text && next.text.toLowerCase() === "as") {
                // 'as' isn't a reserved word, so it can't be lexed into an As token without the lexer
                // understanding language context.  That's less than ideal, so we'll have to do some
                // more intelligent comparisons to detect the 'as' sometimes-keyword here.
                advance();
                typeToken = advance();
                let typeValueKind = brsTypes_1.ValueKind.fromString(typeToken.text);
                if (!typeValueKind) {
                    throw addError(typeToken, `Function parameter '${name.text}' is of invalid type '${typeToken.text}'`);
                }
                type = typeValueKind;
            }
            return {
                name: name,
                type: {
                    kind: type,
                    location: typeToken ? typeToken.location : brsTypes_1.StdlibArgument.InternalLocation,
                },
                defaultValue: defaultValue,
                location: {
                    file: name.location.file,
                    start: name.location.start,
                    end: typeToken ? typeToken.location.end : name.location.end,
                },
            };
        }
        function assignment(...additionalterminators) {
            let name = advance();
            //add error if name is a reserved word that cannot be used as an identifier
            if (disallowedIdentifiers.has(name.text.toLowerCase())) {
                //don't throw...this is fully recoverable
                addError(name, `Cannot use reserved word "${name.text}" as an identifier`);
            }
            let operator = consume(`Expected operator ('=', '+=', '-=', '*=', '/=', '\\=', '^=', '<<=', or '>>=') after idenfifier '${name.text}'`, ...assignmentOperators);
            let value = expression();
            if (!check(...additionalterminators)) {
                consume("Expected newline or ':' after assignment", lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon, lexer_1.Lexeme.Eof, ...additionalterminators);
            }
            if (operator.kind === lexer_1.Lexeme.Equal) {
                return new Stmt.Assignment({ equals: operator }, name, value);
            }
            else {
                return new Stmt.Assignment({ equals: operator }, name, new Expr.Binary(new Expr.Variable(name), operator, value));
            }
        }
        function checkLibrary() {
            let isLibraryIdentifier = check(lexer_1.Lexeme.Identifier) && peek().text.toLowerCase() === "library";
            //if we are at the top level, any line that starts with "library" should be considered a library statement
            if (isAtRootLevel() && isLibraryIdentifier) {
                return true;
            }
            //not at root level, library statements are all invalid here, but try to detect if the tokens look
            //like a library statement (and let the libraryStatement function handle emitting the errors)
            else if (isLibraryIdentifier && checkNext(lexer_1.Lexeme.String)) {
                return true;
            }
            //definitely not a library statement
            else {
                return false;
            }
        }
        function statement(...additionalterminators) {
            if (checkLibrary()) {
                return libraryStatement();
            }
            if (check(lexer_1.Lexeme.Stop)) {
                return stopStatement();
            }
            if (check(lexer_1.Lexeme.If)) {
                return ifStatement();
            }
            if (check(lexer_1.Lexeme.Print)) {
                return printStatement(...additionalterminators);
            }
            if (check(lexer_1.Lexeme.While)) {
                return whileStatement();
            }
            if (check(lexer_1.Lexeme.ExitWhile)) {
                return exitWhile();
            }
            if (check(lexer_1.Lexeme.For)) {
                return forStatement();
            }
            if (check(lexer_1.Lexeme.ForEach)) {
                return forEachStatement();
            }
            if (check(lexer_1.Lexeme.ExitFor)) {
                return exitFor();
            }
            if (checkEnd()) {
                return endStatement();
            }
            if (match(lexer_1.Lexeme.Return)) {
                return returnStatement();
            }
            if (check(lexer_1.Lexeme.Goto)) {
                return gotoStatement();
            }
            //does this line look like a label? (i.e.  `someIdentifier:` )
            if (check(lexer_1.Lexeme.Identifier) && checkNext(lexer_1.Lexeme.Colon)) {
                return labelStatement();
            }
            // TODO: support multi-statements
            return setStatement(...additionalterminators);
        }
        function whileStatement() {
            const whileKeyword = advance();
            const condition = expression();
            consume("Expected newline after 'while ...condition...'", lexer_1.Lexeme.Newline);
            const whileBlock = block(lexer_1.Lexeme.EndWhile);
            if (!whileBlock) {
                throw addError(peek(), "Expected 'end while' to terminate while-loop block");
            }
            const endWhile = advance();
            while (match(lexer_1.Lexeme.Newline))
                ;
            return new Stmt.While({ while: whileKeyword, endWhile: endWhile }, condition, whileBlock);
        }
        function exitWhile() {
            let keyword = advance();
            consume("Expected newline after 'exit while'", lexer_1.Lexeme.Newline);
            while (match(lexer_1.Lexeme.Newline)) { }
            return new Stmt.ExitWhile({ exitWhile: keyword });
        }
        function forStatement() {
            const forKeyword = advance();
            const initializer = assignment(lexer_1.Lexeme.To);
            const to = advance();
            const finalValue = expression();
            let increment;
            let step;
            if (check(lexer_1.Lexeme.Step)) {
                step = advance();
                increment = expression();
            }
            else {
                // BrightScript for/to/step loops default to a step of 1 if no `step` is provided
                increment = new Expr.Literal(new brsTypes_1.Int32(1), peek().location);
            }
            while (match(lexer_1.Lexeme.Newline))
                ;
            let body = block(lexer_1.Lexeme.EndFor, lexer_1.Lexeme.Next);
            if (!body) {
                throw addError(peek(), "Expected 'end for' or 'next' to terminate for-loop block");
            }
            let endFor = advance();
            while (match(lexer_1.Lexeme.Newline))
                ;
            // WARNING: BrightScript doesn't delete the loop initial value after a for/to loop! It just
            // stays around in scope with whatever value it was when the loop exited.
            return new Stmt.For({
                for: forKeyword,
                to: to,
                step: step,
                endFor: endFor,
            }, initializer, finalValue, increment, body);
        }
        function forEachStatement() {
            let forEach = advance();
            let name = advance();
            let maybeIn = peek();
            if (check(lexer_1.Lexeme.Identifier) && maybeIn.text.toLowerCase() === "in") {
                advance();
            }
            else {
                throw addError(maybeIn, "Expected 'in' after 'for each <name>'");
            }
            let target = expression();
            if (!target) {
                throw addError(peek(), "Expected target object to iterate over");
            }
            advance();
            while (match(lexer_1.Lexeme.Newline))
                ;
            let body = block(lexer_1.Lexeme.EndFor, lexer_1.Lexeme.Next);
            if (!body) {
                throw addError(peek(), "Expected 'end for' or 'next' to terminate for-loop block");
            }
            let endFor = advance();
            while (match(lexer_1.Lexeme.Newline))
                ;
            return new Stmt.ForEach({
                forEach: forEach,
                in: maybeIn,
                endFor: endFor,
            }, name, target, body);
        }
        function exitFor() {
            let keyword = advance();
            consume("Expected newline after 'exit for'", lexer_1.Lexeme.Newline);
            while (match(lexer_1.Lexeme.Newline)) { }
            return new Stmt.ExitFor({ exitFor: keyword });
        }
        function libraryStatement() {
            let libraryStatement = new Stmt.Library({
                library: advance(),
                //grab the next token only if it's a string
                filePath: check(lexer_1.Lexeme.String) ? advance() : undefined,
            });
            //no token following library keyword token
            if (!libraryStatement.tokens.filePath && check(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon)) {
                addErrorAtLocation(libraryStatement.tokens.library.location, `Missing string literal after ${libraryStatement.tokens.library.text} keyword`);
            }
            //does not have a string literal as next token
            else if (!libraryStatement.tokens.filePath && peek().kind === lexer_1.Lexeme.Newline) {
                addErrorAtLocation(peek().location, `Expected string literal after ${libraryStatement.tokens.library.text} keyword`);
            }
            //consume all tokens until the end of the line
            let invalidTokens = consumeUntil(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Eof, lexer_1.Lexeme.Colon);
            if (invalidTokens.length > 0) {
                //add an error for every invalid token
                for (let invalidToken of invalidTokens) {
                    addErrorAtLocation(invalidToken.location, `Found unexpected token '${invalidToken.text}' after library statement`);
                }
            }
            //libraries must be at the very top of the file before any other declarations.
            let isAtTopOfFile = true;
            for (let statement of statements) {
                //if we found a non-library statement, this statement is not at the top of the file
                if (!(statement instanceof Stmt.Library)) {
                    isAtTopOfFile = false;
                }
            }
            //libraries must be a root-level statement (i.e. NOT nested inside of functions)
            if (!isAtRootLevel() || !isAtTopOfFile) {
                addErrorAtLocation(libraryStatement.location, "Library statements may only appear at the top of a file");
            }
            //consume to the next newline, eof, or colon
            while (match(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Eof, lexer_1.Lexeme.Colon))
                ;
            return libraryStatement;
        }
        function ifStatement() {
            const ifToken = advance();
            const startingLine = ifToken.location;
            const condition = expression();
            let thenBranch;
            let elseIfBranches = [];
            let elseBranch;
            let thenToken;
            let elseIfTokens = [];
            let endIfToken;
            /**
             * A simple wrapper around `check`, to make tests for a `then` identifier.
             * As with many other words, "then" is a keyword but not reserved, so associative
             * arrays can have properties called "then".  It's a valid identifier sometimes, so the
             * parser has to take on the burden of understanding that I guess.
             * @returns `true` if the next token is an identifier with text "then", otherwise `false`.
             */
            function checkThen() {
                return check(lexer_1.Lexeme.Identifier) && peek().text.toLowerCase() === "then";
            }
            if (checkThen()) {
                // `then` is optional after `if ...condition...`, so only advance to the next token if `then` is present
                thenToken = advance();
            }
            if (match(lexer_1.Lexeme.Newline) || match(lexer_1.Lexeme.Colon)) {
                //consume until no more colons
                while (check(lexer_1.Lexeme.Colon)) {
                    advance();
                }
                //consume exactly 1 newline, if found
                if (check(lexer_1.Lexeme.Newline)) {
                    advance();
                }
                //keep track of the current error count, because if the then branch fails,
                //we will trash them in favor of a single error on if
                let errorsLengthBeforeBlock = errors.length;
                // we're parsing a multi-line ("block") form of the BrightScript if/then/else and must find
                // a trailing "end if"
                let maybeThenBranch = block(lexer_1.Lexeme.EndIf, lexer_1.Lexeme.Else, lexer_1.Lexeme.ElseIf);
                if (!maybeThenBranch) {
                    //throw out any new errors created as a result of a `then` block parse failure.
                    //the block() function will discard the current line, so any discarded errors will
                    //resurface if they are legitimate, and not a result of a malformed if statement
                    errors.splice(errorsLengthBeforeBlock, errors.length - errorsLengthBeforeBlock);
                    //this whole if statement is bogus...add error to the if token and hard-fail
                    throw addError(ifToken, "Expected 'end if', 'else if', or 'else' to terminate 'then' block");
                }
                let blockEnd = previous();
                if (blockEnd.kind === lexer_1.Lexeme.EndIf) {
                    endIfToken = blockEnd;
                }
                thenBranch = maybeThenBranch;
                match(lexer_1.Lexeme.Newline);
                // attempt to read a bunch of "else if" clauses
                while (check(lexer_1.Lexeme.ElseIf)) {
                    elseIfTokens.push(advance());
                    let elseIfCondition = expression();
                    if (checkThen()) {
                        // `then` is optional after `else if ...condition...`, so only advance to the next token if `then` is present
                        advance();
                    }
                    //consume any trailing colons
                    while (check(lexer_1.Lexeme.Colon)) {
                        advance();
                    }
                    match(lexer_1.Lexeme.Newline);
                    let elseIfThen = block(lexer_1.Lexeme.EndIf, lexer_1.Lexeme.Else, lexer_1.Lexeme.ElseIf);
                    if (!elseIfThen) {
                        throw addError(peek(), "Expected 'end if', 'else if', or 'else' to terminate 'then' block");
                    }
                    let blockEnd = previous();
                    if (blockEnd.kind === lexer_1.Lexeme.EndIf) {
                        endIfToken = blockEnd;
                    }
                    elseIfBranches.push({
                        condition: elseIfCondition,
                        thenBranch: elseIfThen,
                    });
                }
                if (match(lexer_1.Lexeme.Else)) {
                    //consume any trailing colons
                    while (check(lexer_1.Lexeme.Colon)) {
                        advance();
                    }
                    match(lexer_1.Lexeme.Newline);
                    elseBranch = block(lexer_1.Lexeme.EndIf);
                    let endIfToken = advance(); // skip past "end if"
                    //ensure that single-line `if` statements have a colon right before 'end if'
                    if (ifToken.location.start.line === endIfToken.location.start.line) {
                        let index = tokens.indexOf(endIfToken);
                        let previousToken = tokens[index - 1];
                        if (previousToken.kind !== lexer_1.Lexeme.Colon) {
                            addError(endIfToken, "Expected ':' to preceed 'end if'");
                        }
                    }
                    match(lexer_1.Lexeme.Newline);
                }
                else {
                    match(lexer_1.Lexeme.Newline);
                    endIfToken = consume(`Expected 'end if' to close 'if' statement started on line ${startingLine}`, lexer_1.Lexeme.EndIf);
                    //ensure that single-line `if` statements have a colon right before 'end if'
                    if (ifToken.location.start.line === endIfToken.location.start.line) {
                        let index = tokens.indexOf(endIfToken);
                        let previousToken = tokens[index - 1];
                        if (previousToken.kind !== lexer_1.Lexeme.Colon) {
                            addError(endIfToken, "Expected ':' to preceed 'end if'");
                        }
                    }
                    match(lexer_1.Lexeme.Newline);
                }
            }
            else {
                let thenStatement = declaration(lexer_1.Lexeme.ElseIf, lexer_1.Lexeme.Else);
                if (!thenStatement) {
                    throw addError(peek(), "Expected a statement to follow 'if ...condition... then'");
                }
                thenBranch = new Stmt.Block([thenStatement], peek().location);
                while (match(lexer_1.Lexeme.ElseIf)) {
                    let elseIf = previous();
                    let elseIfCondition = expression();
                    if (checkThen()) {
                        // `then` is optional after `else if ...condition...`, so only advance to the next token if `then` is present
                        advance();
                    }
                    let elseIfThen = declaration(lexer_1.Lexeme.ElseIf, lexer_1.Lexeme.Else);
                    if (!elseIfThen) {
                        throw addError(peek(), `Expected a statement to follow '${elseIf.text} ...condition... then'`);
                    }
                    elseIfBranches.push({
                        condition: elseIfCondition,
                        thenBranch: new Stmt.Block([elseIfThen], peek().location),
                    });
                }
                if (match(lexer_1.Lexeme.Else)) {
                    let elseStatement = declaration();
                    if (!elseStatement) {
                        throw addError(peek(), `Expected a statement to follow 'else'`);
                    }
                    elseBranch = new Stmt.Block([elseStatement], peek().location);
                }
            }
            return new Stmt.If({
                if: ifToken,
                then: thenToken,
                elseIfs: elseIfTokens,
                endIf: endIfToken,
            }, condition, thenBranch, elseIfBranches, elseBranch);
        }
        function setStatement(...additionalTerminators) {
            /**
             * Attempts to find an expression-statement or an increment statement.
             * While calls are valid expressions _and_ statements, increment (e.g. `foo++`)
             * statements aren't valid expressions. They _do_ however fall under the same parsing
             * priority as standalone function calls though, so we cann parse them in the same way.
             */
            function _expressionStatement() {
                let expressionStart = peek();
                if (check(lexer_1.Lexeme.PlusPlus, lexer_1.Lexeme.MinusMinus)) {
                    let operator = advance();
                    if (check(lexer_1.Lexeme.PlusPlus, lexer_1.Lexeme.MinusMinus)) {
                        throw addError(peek(), "Consecutive increment/decrement operators are not allowed");
                    }
                    else if (expr instanceof Expr.Call) {
                        throw addError(expressionStart, "Increment/decrement operators are not allowed on the result of a function call");
                    }
                    while (match(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon))
                        ;
                    return new Stmt.Increment(expr, operator);
                }
                if (!check(...additionalTerminators)) {
                    consume("Expected newline or ':' after expression statement", lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon, lexer_1.Lexeme.Eof);
                }
                if (expr instanceof Expr.Call) {
                    return new Stmt.Expression(expr);
                }
                throw addError(expressionStart, "Expected statement or function call, but received an expression");
            }
            let expr = call();
            if (check(...assignmentOperators) && !(expr instanceof Expr.Call)) {
                let left = expr;
                let operator = advance();
                let right = expression();
                // Create a dotted or indexed "set" based on the left-hand side's type
                if (left instanceof Expr.IndexedGet) {
                    consume("Expected newline or ':' after indexed 'set' statement", lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon, lexer_1.Lexeme.Eof);
                    return new Stmt.IndexedSet(left.obj, left.index, operator.kind === lexer_1.Lexeme.Equal
                        ? right
                        : new Expr.Binary(left, operator, right), left.closingSquare);
                }
                else if (left instanceof Expr.DottedGet) {
                    consume("Expected newline or ':' after dotted 'set' statement", lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon, lexer_1.Lexeme.Eof);
                    return new Stmt.DottedSet(left.obj, left.name, operator.kind === lexer_1.Lexeme.Equal
                        ? right
                        : new Expr.Binary(left, operator, right));
                }
                else {
                    return _expressionStatement();
                }
            }
            else {
                return _expressionStatement();
            }
        }
        function printStatement(...additionalterminators) {
            let printKeyword = advance();
            let values = [];
            //print statements can be empty, so look for empty print conditions
            if (isAtEnd() || check(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon)) {
                let emptyStringLiteral = new Expr.Literal(new brsTypes_1.BrsString(""), printKeyword.location);
                values.push(emptyStringLiteral);
            }
            else {
                values.push(expression());
            }
            while (!check(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon, ...additionalterminators) && !isAtEnd()) {
                if (check(lexer_1.Lexeme.Semicolon)) {
                    values.push(advance());
                }
                if (check(lexer_1.Lexeme.Comma)) {
                    values.push(advance());
                }
                if (!check(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon) && !isAtEnd()) {
                    values.push(expression());
                }
            }
            if (!check(...additionalterminators)) {
                consume("Expected newline or ':' after printed values", lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon, lexer_1.Lexeme.Eof);
            }
            return new Stmt.Print({ print: printKeyword }, values);
        }
        /**
         * Parses a return statement with an optional return value.
         * @returns an AST representation of a return statement.
         */
        function returnStatement() {
            let tokens = { return: previous() };
            if (check(lexer_1.Lexeme.Colon, lexer_1.Lexeme.Newline, lexer_1.Lexeme.Eof)) {
                while (match(lexer_1.Lexeme.Colon, lexer_1.Lexeme.Newline, lexer_1.Lexeme.Eof))
                    ;
                return new Stmt.Return(tokens);
            }
            let toReturn = expression();
            while (match(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon))
                ;
            return new Stmt.Return(tokens, toReturn);
        }
        /**
         * Parses a `label` statement
         * @returns an AST representation of an `label` statement.
         */
        function labelStatement() {
            let tokens = {
                identifier: advance(),
                colon: advance(),
            };
            consume("Labels must be declared on their own line", lexer_1.Lexeme.Newline, lexer_1.Lexeme.Eof);
            return new Stmt.Label(tokens);
        }
        /**
         * Parses a `goto` statement
         * @returns an AST representation of an `goto` statement.
         */
        function gotoStatement() {
            let tokens = {
                goto: advance(),
                label: consume("Expected label identifier after goto keyword", lexer_1.Lexeme.Identifier),
            };
            while (match(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon))
                ;
            return new Stmt.Goto(tokens);
        }
        /**
         * Parses an `end` statement
         * @returns an AST representation of an `end` statement.
         */
        function endStatement() {
            let tokens = { end: advance() };
            while (match(lexer_1.Lexeme.Newline))
                ;
            return new Stmt.End(tokens);
        }
        /**
         * Parses a `stop` statement
         * @returns an AST representation of a `stop` statement
         */
        function stopStatement() {
            let tokens = { stop: advance() };
            while (match(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon))
                ;
            return new Stmt.Stop(tokens);
        }
        /**
         * Parses a block, looking for a specific terminating Lexeme to denote completion.
         * @param terminators the token(s) that signifies the end of this block; all other terminators are
         *                    ignored.
         */
        function block(...terminators) {
            let startingToken = peek();
            const statements = [];
            while (!check(...terminators) && !isAtEnd()) {
                //grab the location of the current token
                let loopCurrent = current;
                let dec = declaration();
                if (dec) {
                    statements.push(dec);
                }
                else {
                    //something went wrong. reset to the top of the loop
                    current = loopCurrent;
                    //scrap the entire line
                    consumeUntil(lexer_1.Lexeme.Colon, lexer_1.Lexeme.Newline, lexer_1.Lexeme.Eof);
                    //trash the newline character so we start the next iteraion on the next line
                    advance();
                }
            }
            if (isAtEnd()) {
                return undefined;
                // TODO: Figure out how to handle unterminated blocks well
            }
            return new Stmt.Block(statements, startingToken.location);
        }
        function expression() {
            return anonymousFunction();
        }
        function anonymousFunction() {
            if (check(lexer_1.Lexeme.Sub, lexer_1.Lexeme.Function)) {
                return functionDeclaration(true);
            }
            return boolean();
        }
        function boolean() {
            let expr = relational();
            while (match(lexer_1.Lexeme.And, lexer_1.Lexeme.Or)) {
                let operator = previous();
                let right = relational();
                expr = new Expr.Binary(expr, operator, right);
            }
            return expr;
        }
        function relational() {
            let expr = additive();
            while (match(lexer_1.Lexeme.Equal, lexer_1.Lexeme.LessGreater, lexer_1.Lexeme.Greater, lexer_1.Lexeme.GreaterEqual, lexer_1.Lexeme.Less, lexer_1.Lexeme.LessEqual)) {
                let operator = previous();
                let right = additive();
                expr = new Expr.Binary(expr, operator, right);
            }
            return expr;
        }
        // TODO: bitshift
        function additive() {
            let expr = multiplicative();
            while (match(lexer_1.Lexeme.Plus, lexer_1.Lexeme.Minus)) {
                let operator = previous();
                let right = multiplicative();
                expr = new Expr.Binary(expr, operator, right);
            }
            return expr;
        }
        function multiplicative() {
            let expr = exponential();
            while (match(lexer_1.Lexeme.Slash, lexer_1.Lexeme.Backslash, lexer_1.Lexeme.Star, lexer_1.Lexeme.Mod)) {
                let operator = previous();
                let right = exponential();
                expr = new Expr.Binary(expr, operator, right);
            }
            return expr;
        }
        function exponential() {
            let expr = prefixUnary();
            while (match(lexer_1.Lexeme.Caret)) {
                let operator = previous();
                let right = prefixUnary();
                expr = new Expr.Binary(expr, operator, right);
            }
            return expr;
        }
        function prefixUnary() {
            if (match(lexer_1.Lexeme.Not, lexer_1.Lexeme.Minus)) {
                let operator = previous();
                let right = prefixUnary();
                return new Expr.Unary(operator, right);
            }
            return call();
        }
        function call() {
            let expr = primary();
            while (true) {
                if (match(lexer_1.Lexeme.LeftParen)) {
                    expr = finishCall(expr);
                }
                else if (match(lexer_1.Lexeme.LeftSquare)) {
                    while (match(lexer_1.Lexeme.Newline))
                        ;
                    let index = expression();
                    while (match(lexer_1.Lexeme.Newline))
                        ;
                    let closingSquare = consume("Expected ']' after array or object index", lexer_1.Lexeme.RightSquare);
                    expr = new Expr.IndexedGet(expr, index, closingSquare);
                }
                else if (match(lexer_1.Lexeme.Dot)) {
                    while (match(lexer_1.Lexeme.Newline))
                        ;
                    let name = consume("Expected property name after '.'", lexer_1.Lexeme.Identifier, ...allowedProperties);
                    // force it into an identifier so the AST makes some sense
                    name.kind = lexer_1.Lexeme.Identifier;
                    expr = new Expr.DottedGet(expr, name);
                }
                else {
                    break;
                }
            }
            return expr;
        }
        function finishCall(callee) {
            let args = [];
            while (match(lexer_1.Lexeme.Newline))
                ;
            if (!check(lexer_1.Lexeme.RightParen)) {
                do {
                    while (match(lexer_1.Lexeme.Newline))
                        ;
                    if (args.length >= Expr.Call.MaximumArguments) {
                        throw addError(peek(), `Cannot have more than ${Expr.Call.MaximumArguments} arguments`);
                    }
                    args.push(expression());
                } while (match(lexer_1.Lexeme.Comma));
            }
            while (match(lexer_1.Lexeme.Newline))
                ;
            const closingParen = consume("Expected ')' after function call arguments", lexer_1.Lexeme.RightParen);
            return new Expr.Call(callee, closingParen, args);
        }
        function primary() {
            switch (true) {
                case match(lexer_1.Lexeme.False):
                    return new Expr.Literal(brsTypes_1.BrsBoolean.False, previous().location);
                case match(lexer_1.Lexeme.True):
                    return new Expr.Literal(brsTypes_1.BrsBoolean.True, previous().location);
                case match(lexer_1.Lexeme.Invalid):
                    return new Expr.Literal(brsTypes_1.BrsInvalid.Instance, previous().location);
                case match(lexer_1.Lexeme.Integer, lexer_1.Lexeme.LongInteger, lexer_1.Lexeme.Float, lexer_1.Lexeme.Double, lexer_1.Lexeme.String):
                    return new Expr.Literal(previous().literal, previous().location);
                case match(lexer_1.Lexeme.Identifier):
                    return new Expr.Variable(previous());
                case match(lexer_1.Lexeme.LeftParen):
                    let left = previous();
                    let expr = expression();
                    let right = consume("Unmatched '(' - expected ')' after expression", lexer_1.Lexeme.RightParen);
                    return new Expr.Grouping({ left, right }, expr);
                case match(lexer_1.Lexeme.LeftSquare):
                    let elements = [];
                    let openingSquare = previous();
                    while (match(lexer_1.Lexeme.Newline))
                        ;
                    if (!match(lexer_1.Lexeme.RightSquare)) {
                        elements.push(expression());
                        while (match(lexer_1.Lexeme.Comma, lexer_1.Lexeme.Newline)) {
                            while (match(lexer_1.Lexeme.Newline))
                                ;
                            if (check(lexer_1.Lexeme.RightSquare)) {
                                break;
                            }
                            elements.push(expression());
                        }
                        consume("Unmatched '[' - expected ']' after array literal", lexer_1.Lexeme.RightSquare);
                    }
                    let closingSquare = previous();
                    //consume("Expected newline or ':' after array literal", Lexeme.Newline, Lexeme.Colon, Lexeme.Eof);
                    return new Expr.ArrayLiteral(elements, openingSquare, closingSquare);
                case match(lexer_1.Lexeme.LeftBrace):
                    let openingBrace = previous();
                    let members = [];
                    function key() {
                        let k;
                        if (check(lexer_1.Lexeme.Identifier, ...allowedProperties)) {
                            k = new brsTypes_1.BrsString(advance().text);
                        }
                        else if (check(lexer_1.Lexeme.String)) {
                            k = advance().literal;
                        }
                        else {
                            throw addError(peek(), `Expected identifier or string as associative array key, but received '${peek()
                                .text || ""}'`);
                        }
                        consume("Expected ':' between associative array key and value", lexer_1.Lexeme.Colon);
                        return k;
                    }
                    while (match(lexer_1.Lexeme.Newline))
                        ;
                    if (!match(lexer_1.Lexeme.RightBrace)) {
                        members.push({
                            name: key(),
                            value: expression(),
                        });
                        while (match(lexer_1.Lexeme.Comma, lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon)) {
                            while (match(lexer_1.Lexeme.Newline, lexer_1.Lexeme.Colon))
                                ;
                            if (check(lexer_1.Lexeme.RightBrace)) {
                                break;
                            }
                            members.push({
                                name: key(),
                                value: expression(),
                            });
                        }
                        consume("Unmatched '{' - expected '}' after associative array literal", lexer_1.Lexeme.RightBrace);
                    }
                    let closingBrace = previous();
                    return new Expr.AALiteral(members, openingBrace, closingBrace);
                case match(lexer_1.Lexeme.Pos, lexer_1.Lexeme.Tab):
                    let token = Object.assign(previous(), {
                        kind: lexer_1.Lexeme.Identifier,
                    });
                    return new Expr.Variable(token);
                case check(lexer_1.Lexeme.Function, lexer_1.Lexeme.Sub):
                    return anonymousFunction();
                default:
                    throw addError(peek(), `Found unexpected token '${peek().text}'`);
            }
        }
        function match(...lexemes) {
            for (let lexeme of lexemes) {
                if (check(lexeme)) {
                    advance();
                    return true;
                }
            }
            return false;
        }
        /**
         * Consume tokens until one of the `stopLexemes` is encountered
         * @param lexemes
         * @return - the list of tokens consumed, EXCLUDING the `stopLexeme` (you can use `peek()` to see which one it was)
         */
        function consumeUntil(...stopLexemes) {
            let result = [];
            //take tokens until we encounter one of the stopLexemes
            while (!stopLexemes.includes(peek().kind)) {
                result.push(advance());
            }
            return result;
        }
        function consume(message, ...lexemes) {
            let foundLexeme = lexemes
                .map(lexeme => peek().kind === lexeme)
                .reduce((foundAny, foundCurrent) => foundAny || foundCurrent, false);
            if (foundLexeme) {
                return advance();
            }
            throw addError(peek(), message);
        }
        function advance() {
            if (!isAtEnd()) {
                current++;
            }
            return previous();
        }
        /**
         * Check that the previous token matches one of the specified Lexemes
         * @param lexemes
         */
        function checkPrevious(...lexemes) {
            if (current === 0) {
                return false;
            }
            else {
                current--;
                var result = check(...lexemes);
                current++;
                return result;
            }
        }
        function check(...lexemes) {
            if (isAtEnd()) {
                return false;
            }
            return lexemes.some(lexeme => peek().kind === lexeme);
        }
        function checkNext(...lexemes) {
            if (isAtEnd()) {
                return false;
            }
            return lexemes.some(lexeme => peekNext().kind === lexeme);
        }
        function isAtEnd() {
            return peek().kind === lexer_1.Lexeme.Eof;
        }
        function peekNext() {
            if (isAtEnd()) {
                return peek();
            }
            return tokens[current + 1];
        }
        function peek() {
            return tokens[current];
        }
        function previous() {
            return tokens[current - 1];
        }
        function synchronize() {
            advance(); // skip the erroneous token
            while (!isAtEnd()) {
                if (previous().kind === lexer_1.Lexeme.Newline || previous().kind === lexer_1.Lexeme.Colon) {
                    // newlines and ':' characters separate statements
                    return;
                }
                switch (peek().kind) {
                    case lexer_1.Lexeme.Function:
                    case lexer_1.Lexeme.Sub:
                    case lexer_1.Lexeme.If:
                    case lexer_1.Lexeme.For:
                    case lexer_1.Lexeme.ForEach:
                    case lexer_1.Lexeme.While:
                    case lexer_1.Lexeme.Print:
                    case lexer_1.Lexeme.Return:
                        // start parsing again from the next block starter or obvious
                        // expression start
                        return;
                }
                advance();
            }
        }
    }
}
exports.Parser = Parser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BhcnNlci9QYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbUNBQXNDO0FBRXRDLG1EQUFxQztBQUVyQyxrREFBb0M7QUFFcEMsb0NBQThFO0FBQzlFLDZDQUEwQztBQUUxQywwQ0FRcUI7QUFhckIsbUVBQW1FO0FBQ25FLE1BQU0sbUJBQW1CLEdBQUc7SUFDeEIsY0FBTSxDQUFDLEtBQUs7SUFDWixjQUFNLENBQUMsVUFBVTtJQUNqQixjQUFNLENBQUMsU0FBUztJQUNoQixjQUFNLENBQUMsU0FBUztJQUNoQixjQUFNLENBQUMsVUFBVTtJQUNqQixjQUFNLENBQUMsY0FBYztJQUNyQixjQUFNLENBQUMsY0FBYztJQUNyQixjQUFNLENBQUMsZUFBZTtDQUN6QixDQUFDO0FBRUYsNERBQTREO0FBQzVELE1BQU0saUJBQWlCLEdBQUc7SUFDdEIsY0FBTSxDQUFDLEdBQUc7SUFDVixjQUFNLENBQUMsR0FBRztJQUNWLGNBQU0sQ0FBQyxZQUFZO0lBQ25CLGNBQU0sQ0FBQyxHQUFHO0lBQ1YsY0FBTSxDQUFDLElBQUk7SUFDWCxjQUFNLENBQUMsTUFBTTtJQUNiLGNBQU0sQ0FBQyxHQUFHO0lBQ1YsY0FBTSxDQUFDLFdBQVc7SUFDbEIsY0FBTSxDQUFDLE1BQU07SUFDYixjQUFNLENBQUMsS0FBSztJQUNaLGNBQU0sQ0FBQyxNQUFNO0lBQ2IsY0FBTSxDQUFDLFFBQVE7SUFDZixjQUFNLENBQUMsSUFBSTtJQUNYLGNBQU0sQ0FBQyxJQUFJO0lBQ1gsY0FBTSxDQUFDLE9BQU87SUFDZCxjQUFNLENBQUMsU0FBUztJQUNoQixjQUFNLENBQUMsS0FBSztJQUNaLGNBQU0sQ0FBQyxHQUFHO0lBQ1YsY0FBTSxDQUFDLE9BQU87SUFDZCxjQUFNLENBQUMsUUFBUTtJQUNmLGNBQU0sQ0FBQyxXQUFXO0lBQ2xCLGNBQU0sQ0FBQyxzQkFBc0I7SUFDN0Is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