"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var brs = require("brs");
var Debug = require("debug");
var path = require("path");
var CodeCoverageType_1 = require("./CodeCoverageType");
var File_1 = require("./File");
var debug = Debug('CodeCoverageProcessor');
var CodeCoverageProcessor = /** @class */ (function () {
    function CodeCoverageProcessor(config) {
        this._config = config;
        this._fileId = 0;
        var fs = require('fs');
        this._filePathMap = new Map();
        this._expectedCoverageMap = {};
        try {
            this._coverageBrsTemplate = fs.readFileSync(path.join(__dirname, './CodeCoverageTemplate.brs'), 'utf8');
            this._coverageComponentBrsTemplate = fs.readFileSync(path.join(__dirname, './CodeCoverage.brs'), 'utf8');
            this._coverageComponentXmlTemplate = fs.readFileSync(path.join(__dirname, './CodeCoverage.xml'), 'utf8');
            this._coverageSupportTemplate = fs.readFileSync(path.join(__dirname, './CodeCoverageSupport.brs'), 'utf8');
        }
        catch (e) {
            console.log('Error:', e.stack);
        }
    }
    Object.defineProperty(CodeCoverageProcessor.prototype, "config", {
        get: function () {
            return this._config;
        },
        enumerable: true,
        configurable: true
    });
    CodeCoverageProcessor.prototype.process = function () {
        return __awaiter(this, void 0, void 0, function () {
            var glob, processedFiles, targetPath, files, _i, files_1, filePath, extension, projectPath, fullPath, filename, file, lexResult, parser, parseResult;
            return __generator(this, function (_a) {
                debug("Running processor at path " + this.config.projectPath + " ");
                glob = require('glob-all');
                processedFiles = [];
                targetPath = path.resolve(this._config.projectPath);
                debug("processing files at path " + targetPath + " with pattern " + this._config.sourceFilePattern);
                files = glob.sync(this._config.sourceFilePattern, { cwd: targetPath });
                for (_i = 0, files_1 = files; _i < files_1.length; _i++) {
                    filePath = files_1[_i];
                    extension = path.extname(filePath).toLowerCase();
                    if (extension === '.brs') {
                        projectPath = path.dirname(filePath);
                        fullPath = path.join(targetPath, projectPath);
                        filename = path.basename(filePath);
                        file = new File_1.default(fullPath, projectPath, filename, path.extname(filename));
                        lexResult = brs.lexer.Lexer.scan(file.getFileContents());
                        parser = new brs.parser.Parser();
                        parseResult = parser.parse(lexResult.tokens);
                        file.ast = parseResult.statements;
                        this.processFile(file);
                        processedFiles.push(file);
                    }
                }
                this.createCoverageComponent();
                this.createCoverageSupport();
                debug("finished processing code coverage");
                return [2 /*return*/];
            });
        });
    };
    CodeCoverageProcessor.prototype.processFile = function (file) {
        this._fileId++;
        var fileContents = '';
        var lines = file.getFileContents().split(/\r?\n/);
        var coverageMap = new Map();
        this.visitableLines = new Map();
        this.getVisitableLinesForStatements(file.ast);
        for (var lineNumber = 0; lineNumber < lines.length; lineNumber++) {
            var line = lines[lineNumber];
            var statement = this.visitableLines.get(lineNumber);
            var coverageType = CodeCoverageType_1.CodeCoverageLineType.noCode;
            if (statement) {
                if (statement instanceof brs.parser.Stmt.If) {
                    var conditionStartPos = statement.condition.location.start.column;
                    var conditionEndPos = statement.condition.location.end.column;
                    var funcCall = this.getFuncCallText(lineNumber, CodeCoverageType_1.CodeCoverageLineType.condition);
                    var conditionText = line.substr(conditionStartPos, conditionEndPos - conditionStartPos);
                    var restofLineText = line.substring(conditionEndPos);
                    line = line.substr(0, conditionStartPos) + " " + funcCall + " and (" + conditionText + ") " + restofLineText;
                    coverageType = CodeCoverageType_1.CodeCoverageLineType.condition;
                }
                else if (statement instanceof ElseIfStatement) {
                    var conditionStartPos = statement.condition.location.start.column;
                    var conditionEndPos = statement.condition.location.end.column;
                    var funcCall = this.getFuncCallText(lineNumber, CodeCoverageType_1.CodeCoverageLineType.condition);
                    var conditionText = line.substr(conditionStartPos, conditionEndPos - conditionStartPos);
                    var restofLineText = line.substring(conditionEndPos);
                    line = line.substr(0, conditionStartPos) + " " + funcCall + " and (" + conditionText + ") " + restofLineText;
                    coverageType = CodeCoverageType_1.CodeCoverageLineType.condition;
                }
                else {
                    //all types that can be prefixed with the funcall and a colon (i.e for, while, return foreach, assign)
                    var funcCall = this.getFuncCallText(lineNumber, CodeCoverageType_1.CodeCoverageLineType.code);
                    line = funcCall + ": " + line;
                    coverageType = CodeCoverageType_1.CodeCoverageLineType.code;
                }
            }
            else {
                debug("could not ascertain symbol type for line \"" + line + " - ignoring");
            }
            if (!line.endsWith('\n')) {
                line += '\n';
            }
            fileContents += line;
            if (coverageType > CodeCoverageType_1.CodeCoverageLineType.noCode) {
                coverageMap.set(lineNumber, coverageType);
            }
        }
        this._expectedCoverageMap[this._fileId.toString().trim()] = Array.from(coverageMap);
        this._filePathMap[this._fileId] = file.pkgUri;
        fileContents += this.getBrsAPIText();
        file.setFileContents(fileContents);
        debug("Writing to " + file.fullPath);
        file.saveFileContents();
    };
    CodeCoverageProcessor.prototype.getBrsAPIText = function () {
        var template = this._coverageBrsTemplate.replace(/\#ID\#/g, this._fileId.toString().trim());
        return template;
    };
    CodeCoverageProcessor.prototype.createCoverageComponent = function () {
        var targetPath = path.resolve(this._config.projectPath);
        var file = new File_1.default(path.resolve(path.join(targetPath), 'components'), 'components', 'CodeCoverage.xml', '.xml');
        file.setFileContents(this._coverageComponentXmlTemplate);
        debug("Writing to " + file.fullPath);
        file.saveFileContents();
        file = new File_1.default(path.resolve(path.join(targetPath, 'components')), 'components', 'CodeCoverage.brs', '.brs');
        var template = this._coverageComponentBrsTemplate;
        template = template.replace(/\#EXPECTED_MAP\#/g, JSON.stringify(this._expectedCoverageMap));
        template = template.replace(/\#FILE_PATH_MAP\#/g, JSON.stringify(this._filePathMap));
        file.setFileContents(template);
        debug("Writing to " + file.fullPath);
        file.saveFileContents();
    };
    CodeCoverageProcessor.prototype.createCoverageSupport = function () {
        var targetPath = path.resolve(this._config.projectPath);
        var file = new File_1.default(path.resolve(path.join(targetPath), 'source'), 'source', 'CodeCoverageSupport.brs', '.brs');
        file.setFileContents(this._coverageSupportTemplate);
        debug("Writing to " + file.fullPath);
        file.saveFileContents();
    };
    CodeCoverageProcessor.prototype.getFuncCallText = function (lineNumber, lineType) {
        return "RBS_CC_" + this._fileId + "_reportLine(" + lineNumber.toString().trim() + ", " + lineType.toString().trim() + ")";
    };
    CodeCoverageProcessor.prototype.getVisitableLinesForStatements = function (statements) {
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var statement = statements_1[_i];
            if (statement instanceof brs.parser.Stmt.Function) {
                this.getVisitableLinesForStatements(statement.func.body.statements);
            }
            else if (statement instanceof brs.parser.Stmt.Assignment
                || statement instanceof brs.parser.Stmt.DottedSet
                || statement instanceof brs.parser.Stmt.IndexedSet) {
                this.addStatement(statement);
                this.getVisitableLinesForExpression([statement.value]);
            }
            else if (statement instanceof brs.parser.Stmt.If) {
                this.addStatement(statement);
                if (statement.thenBranch) {
                    this.getVisitableLinesForStatements(statement.thenBranch.statements);
                }
                if (statement.elseIfs) {
                    for (var i = 0; i < statement.elseIfs.length; i++) {
                        var elseIfStatement = statement.elseIfs[i];
                        this.getVisitableLinesForStatements(elseIfStatement.thenBranch.statements);
                        if (statement.tokens.elseIfs[i]) {
                            var elseIfLine = statement.tokens.elseIfs[i].location.start.line - 1;
                            this.addStatement(new ElseIfStatement(elseIfStatement.condition), elseIfLine);
                        }
                    }
                }
                if (statement.elseBranch) {
                    this.getVisitableLinesForStatements(statement.elseBranch.statements);
                }
            }
            else if (statement instanceof brs.parser.Stmt.For
                || statement instanceof brs.parser.Stmt.ForEach
                || statement instanceof brs.parser.Stmt.While) {
                this.addStatement(statement);
                this.getVisitableLinesForStatements(statement.body.statements);
            }
            else if (statement instanceof brs.parser.Stmt.Expression) {
                this.addStatement(statement);
                this.getVisitableLinesForExpression([statement.expression]);
            }
            else if (statement instanceof brs.parser.Stmt.Assignment
                || statement instanceof brs.parser.Stmt.Print
                || statement instanceof brs.parser.Stmt.Return) {
                this.addStatement(statement);
            }
            else {
                debug("unknown statement type");
            }
        }
    };
    CodeCoverageProcessor.prototype.addStatement = function (statement, lineNumber) {
        if (!lineNumber) {
            if (!(statement instanceof ElseIfStatement)) {
                lineNumber = statement.location.start.line - 1;
            }
            else {
                console.log('addStatement called with otherStatement, without a line number! - OtherStatements types must provide a line number');
            }
        }
        if (!this.visitableLines.has(lineNumber)) {
            this.visitableLines.set(lineNumber, statement);
        }
        else {
            debug("line was already registered");
        }
    };
    CodeCoverageProcessor.prototype.getVisitableLinesForExpression = function (expressions) {
        for (var _i = 0, expressions_1 = expressions; _i < expressions_1.length; _i++) {
            var expression = expressions_1[_i];
            if (expression instanceof brs.parser.Expr.AALiteral) {
                this.getVisitableLinesForExpression(expression.elements.map(function (e) { return e.value; }));
            }
            else if (expression instanceof brs.parser.Expr.ArrayLiteral) {
                this.getVisitableLinesForExpression(expression.elements);
            }
            else if (expression instanceof brs.parser.Expr.Call) {
                this.getVisitableLinesForExpression(expression.args);
            }
            else if (expression instanceof brs.parser.Expr.Binary) {
                this.getVisitableLinesForExpression([expression.left]);
                this.getVisitableLinesForExpression([expression.right]);
            }
            else if (expression instanceof brs.parser.Expr.Function) {
                this.getVisitableLinesForStatements(expression.body.statements);
            }
            else if (expression instanceof brs.parser.Expr.Literal
                || expression instanceof brs.parser.Expr.Variable
                || expression instanceof brs.parser.Expr.DottedGet) {
                debug('known non-visitable expression: ' + expression.constructor.name);
            }
            else {
                debug("unknown expression");
            }
        }
    };
    return CodeCoverageProcessor;
}());
exports.CodeCoverageProcessor = CodeCoverageProcessor;
var ElseIfStatement = /** @class */ (function () {
    function ElseIfStatement(condition) {
        this.condition = condition;
    }
    return ElseIfStatement;
}());
