"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Debug = require("debug");
var Feedback_1 = require("./Feedback");
var ItGroup_1 = require("./ItGroup");
var Tag_1 = require("./Tag");
var TestCase_1 = require("./TestCase");
var TestSuite_1 = require("./TestSuite");
var debug = Debug('RooibosProcessor');
var getJsonFromString = require('./getJsonFromString');
var TestSuiteBuilder = /** @class */ (function () {
    function TestSuiteBuilder(maxLinesWithoutSuiteDirective, isLegacyTestsSupported) {
        this.testSuiteNames = new Set();
        this._maxLinesWithoutSuiteDirective = maxLinesWithoutSuiteDirective;
        this.functionNameRegex = new RegExp('^\\s*(function|sub)\\s*([0-9a-z_]*)s*\\(', 'i');
        this.functionSignatureRegex = new RegExp('^\\s*(function|sub)\\s*[0-9a-z_]*s*\\((.*)\\)', 'i');
        this.assertInvocationRegex = new RegExp('^\\s*(m\\.fail|m\\.assert)(.*)\\(', 'i');
        this.functionEndRegex = new RegExp('^\s*(end sub|end function)', 'i');
        this.paramsInvalidToNullRegex = /(,|\:|\[)(\s*)(invalid)/g;
        this._warnings = [];
        this._errors = [];
        this._isLegacyTestsSupported = isLegacyTestsSupported;
    }
    Object.defineProperty(TestSuiteBuilder.prototype, "errors", {
        get: function () {
            return this._errors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TestSuiteBuilder.prototype, "warnings", {
        get: function () {
            return this._warnings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TestSuiteBuilder.prototype, "maxLinesWithoutSuiteDirective", {
        get: function () {
            return this._maxLinesWithoutSuiteDirective;
        },
        enumerable: true,
        configurable: true
    });
    TestSuiteBuilder.prototype.processFile = function (file) {
        var _this = this;
        var code = file ? file.getFileContents() : null;
        var testSuite = new TestSuite_1.TestSuite();
        if (!code || !code.trim()) {
            debug("no code for current descriptor");
            this.errors.push('No code for file' + (file ? file.fullPath : "unknown file"));
            return testSuite;
        }
        var isTokenItGroup = false;
        var isNextTokenIgnore = false;
        var isNextTokenSolo = false;
        var isNextTokenTest = false;
        var isTestSuite = false;
        var isNextTokenSetup = false;
        var isNextTokenTearDown = false;
        var isNextTokenBeforeEach = false;
        var isNextTokenAfterEach = false;
        var isNextTokenNodeTest = false;
        var isNextTokenTestCaseParam = false;
        var nodeTestFileName = '';
        var nextName = '';
        var name = file.normalizedFileName;
        var filename = file.normalizedFileName;
        var currentLocation = '';
        var lines = code.split(/\r?\n/);
        var filePath = file.fullPath;
        testSuite.filePath = file.pkgPath;
        this.currentGroup = null;
        this.reset();
        var itGroupNames = new Set();
        var _loop_1 = function (lineNumber) {
            currentLocation = filePath + ':' + lineNumber.toString();
            var line = lines[lineNumber - 1];
            // debug(line);
            if (lineNumber > this_1._maxLinesWithoutSuiteDirective && !isTestSuite) {
                debug('NO TESTSUITE DIRECTIVE : ' + currentLocation);
                return "break";
            }
            if (this_1.isTag(line, Tag_1.Tag.TEST_SUITE)) {
                if (isTestSuite) {
                    debug("Multiple suites per file are !supported - use '@It tag");
                    this_1.warnings.push('Multiple suites per file are !supported - use \'@It tag' + currentLocation);
                }
                name = this_1.getTagText(line, Tag_1.Tag.TEST_SUITE);
                if (name) {
                    if (this_1.testSuiteNames.has(name)) {
                        Feedback_1.feedbackError(file, "\nTest suite with name '" + name + "' has already been defined!");
                    }
                    testSuite.name = name;
                    this_1.testSuiteNames.add(name);
                }
                if (isNextTokenSolo) {
                    testSuite.isSolo = true;
                    testSuite.name += " [ONLY]";
                }
                isTestSuite = true;
                testSuite.isValid = true;
                if (isNextTokenNodeTest) {
                    testSuite.nodeTestFileName = nodeTestFileName;
                    testSuite.isNodeTest = true;
                }
                if (isNextTokenIgnore) {
                    testSuite.isIgnored = true;
                    return "break";
                }
                isNextTokenSolo = false;
                isNextTokenIgnore = false;
                isNextTokenNodeTest = false;
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.IT)) {
                if (!isTestSuite) {
                    debug("File !identified as testsuite!");
                }
                name = this_1.getTagText(line, Tag_1.Tag.IT);
                if (name === "") {
                    name = "UNNAMED Tag.TEST GROUP - name this group for better readability - e.g. 'Tests the Load method... '";
                }
                if (itGroupNames.has(name)) {
                    Feedback_1.feedbackError(file, "\nIt group with name '" + name + "' has already been defined in this test suite");
                }
                itGroupNames.add(name);
                this_1.currentGroup = new ItGroup_1.ItGroup(name, isNextTokenSolo, isNextTokenIgnore, filename);
                this_1.currentGroup.file = file;
                // 'inherit all suite functions that were set up to no';
                this_1.currentGroup.setupFunctionName = testSuite.setupFunctionName;
                this_1.currentGroup.tearDownFunctionName = testSuite.tearDownFunctionName;
                this_1.currentGroup.beforeEachFunctionName = testSuite.beforeEachFunctionName;
                this_1.currentGroup.afterEachFunctionName = testSuite.afterEachFunctionName;
                testSuite.itGroups.push(this_1.currentGroup);
                if (isNextTokenSolo) {
                    testSuite.hasSoloGroups = true;
                    testSuite.isSolo = true;
                }
                isTokenItGroup = true;
            }
            else if (this_1.isTag(line, Tag_1.Tag.SOLO) && !this_1.isTag(line, Tag_1.Tag.TEST_SOLO_PARAMS)) {
                if (isNextTokenSolo) {
                    debug("Tag.TEST MARKED FOR Tag.IGNORE AND Tag.SOLO");
                    this_1.warnings.push("Tag.TEST MARKED FOR Tag.IGNORE AND Tag.SOLO " + currentLocation);
                }
                else {
                    isNextTokenSolo = true;
                    // debug('isNextTokenSolo is true!! ' + line + ' ' + currentLocation);
                }
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.IGNORE) && !this_1.isTag(line, Tag_1.Tag.TEST_IGNORE_PARAMS)) {
                isNextTokenIgnore = true;
                testSuite.hasIgnoredTests = true;
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.NODE_TEST)) {
                if (isTestSuite) {
                    debug("FOUND " + Tag_1.Tag.NODE_TEST + " AFTER '@TestSuite annotation - This test will subsequently !run as a node test. ");
                    debug("If you wish to run this suite of tests on a node, then make sure the " + Tag_1.Tag.NODE_TEST + " annotation appeares before the " + Tag_1.Tag.TEST_SUITE + " Annotation");
                    this_1.warnings.push("FOUND " + Tag_1.Tag.NODE_TEST + (" AFTER '@TestSuite annotation - This test will subsequently !run as a node test. " + currentLocation));
                    this_1.warnings.push("If you wish to run this suite of tests on a node, then make sure the " + Tag_1.Tag.NODE_TEST + " annotation appeares before the " + Tag_1.Tag.TEST_SUITE + " Annotation");
                }
                nodeTestFileName = this_1.getTagText(line, Tag_1.Tag.NODE_TEST);
                isNextTokenNodeTest = true;
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.TEST)) {
                if (!isTestSuite) {
                    debug("FOUND " + Tag_1.Tag.TEST + " BEFORE '@TestSuite declaration - skipping test file! " + currentLocation);
                    this_1.warnings.push("FOUND " + Tag_1.Tag.TEST + " BEFORE '@TestSuite declaration - skipping test file! " + currentLocation);
                    return "break";
                }
                if (!this_1.currentGroup) {
                    debug("FOUND " + Tag_1.Tag.TEST + " BEFORE '@It declaration - skipping test file!" + currentLocation);
                    this_1.warnings.push("FOUND " + Tag_1.Tag.TEST + " BEFORE '@It declaration - skipping test file!" + currentLocation);
                    return "break";
                }
                this_1.reset();
                isNextTokenTest = true;
                nextName = this_1.getTagText(line, Tag_1.Tag.TEST);
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.SETUP)) {
                if (!isTestSuite) {
                    debug("FOUND " + Tag_1.Tag.SETUP + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    this_1.errors.push("FOUND " + Tag_1.Tag.SETUP + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    return "break";
                }
                isNextTokenSetup = true;
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.TEAR_DOWN)) {
                if (!isTestSuite) {
                    debug("FOUND " + Tag_1.Tag.TEAR_DOWN + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    this_1.errors.push("FOUND " + Tag_1.Tag.TEAR_DOWN + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    return "break";
                }
                isNextTokenTearDown = true;
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.BEFORE_EACH)) {
                if (!isTestSuite) {
                    debug("FOUND " + Tag_1.Tag.BEFORE_EACH + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    this_1.errors.push("FOUND " + Tag_1.Tag.BEFORE_EACH + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    return "break";
                }
                isNextTokenBeforeEach = true;
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.AFTER_EACH)) {
                if (!isTestSuite) {
                    debug("FOUND " + Tag_1.Tag.AFTER_EACH + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    this_1.errors.push("FOUND " + Tag_1.Tag.AFTER_EACH + " BEFORE '@TestSuite declaration - skipping test file!" + currentLocation);
                    return "break";
                }
                isNextTokenAfterEach = true;
                return "continue";
            }
            else if (line.match(this_1.assertInvocationRegex)) {
                if (!this_1.hasCurrentTestCase) {
                    debug("Found assert before test case was declared! " + currentLocation);
                    this_1.warnings.push("Found assert before test case was declared! " + currentLocation);
                }
                else {
                    this_1.currentTestCases.forEach(function (tc) { return tc.addAssertLine(lineNumber); });
                }
                return "continue";
            }
            else if (isNextTokenTest && line.match(this_1.functionEndRegex)) {
                this_1.reset();
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.TEST_IGNORE_PARAMS)) {
                isNextTokenTestCaseParam = true; //this keeps the processing going down to the function
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.TEST_PARAMS)) {
                if (!isNextTokenTest) {
                    debug("FOUND " + Tag_1.Tag.TEST + " PARAM WITHOUT @Test declaration " + currentLocation);
                    this_1.warnings.push("FOUND " + Tag_1.Tag.TEST + " PARAM WITHOUT @Test declaration " + currentLocation);
                }
                else {
                    isNextTokenTestCaseParam = true;
                    this_1.addParamsForLine(line, Tag_1.Tag.TEST_PARAMS, lineNumber, this_1.testCaseParamLines, this_1.testCaseParams, currentLocation);
                }
                return "continue";
            }
            else if (this_1.isTag(line, Tag_1.Tag.TEST_SOLO_PARAMS)) {
                if (!isNextTokenTest) {
                    debug("FOUND " + Tag_1.Tag.TEST_SOLO_PARAMS + " PARAM WITHOUT @Test declaration " + currentLocation);
                    this_1.warnings.push("FOUND " + Tag_1.Tag.TEST_SOLO_PARAMS + " PARAM WITHOUT @Test declaration " + currentLocation);
                }
                else {
                    isNextTokenSolo = true;
                    isNextTokenTestCaseParam = true;
                    this_1.addParamsForLine(line, Tag_1.Tag.TEST_SOLO_PARAMS, lineNumber, this_1.testCaseOnlyParamLines, this_1.testCaseOnlyParams, currentLocation);
                }
                return "continue";
            }
            if (isTokenItGroup || isNextTokenTest || isNextTokenSetup || isNextTokenBeforeEach || isNextTokenAfterEach || isNextTokenTearDown) {
                //have to find a function definition here - if it's !then this i {
                var functionName = this_1.getFunctionFromLine(line);
                if (functionName) {
                    var numberOfExpectedParams = this_1.getNumberOfExpectedParamsFromLine(line);
                    if (isNextTokenTest) {
                        var testName = nextName || functionName;
                        nodeTestFileName = nodeTestFileName || testSuite.nodeTestFileName;
                        if (this_1.testCaseParams.length > 0 || this_1.testCaseOnlyParams.length > 0) {
                            var paramsToUse = [];
                            var paramLineNumbersToUse = [];
                            if (this_1.testCaseOnlyParams.length > 0) {
                                paramsToUse = this_1.testCaseOnlyParams;
                                paramLineNumbersToUse = this_1.testCaseOnlyParamLines;
                            }
                            else {
                                paramsToUse = this_1.testCaseParams;
                                paramLineNumbersToUse = this_1.testCaseParamLines;
                            }
                            for (var index = 0; index < paramsToUse.length; index++) {
                                var params = paramsToUse[index];
                                var paramLineNumber = paramLineNumbersToUse[index];
                                var testCase = new TestCase_1.TestCase(testName, functionName, isNextTokenSolo, isNextTokenIgnore, lineNumber, params, index, paramLineNumber, numberOfExpectedParams);
                                testCase.isParamTest = true;
                                if (testCase) {
                                    this_1.currentTestCases.push(testCase);
                                }
                                else {
                                    debug("Skipping unparseable params for testcase " + params + " @" + currentLocation);
                                    this_1.warnings.push("Skipping unparseable params for testcase " + params + " @" + currentLocation);
                                }
                            }
                        }
                        else {
                            var testCase = new TestCase_1.TestCase(testName, functionName, isNextTokenSolo, isNextTokenIgnore, lineNumber);
                            testCase.expectedNumberOfParams = numberOfExpectedParams;
                            this_1.currentTestCases.push(testCase);
                        }
                        if (this_1.currentGroup) {
                            this_1.currentTestCases.forEach(function (aTestCase) {
                                _this.currentGroup.addTestCase(aTestCase);
                                if (aTestCase.isSolo) {
                                    // debug('>>> ' + aTestCase.name + ' IS SOLO!');
                                    testSuite.hasSoloTests = true;
                                }
                            });
                            this_1.hasCurrentTestCase = true;
                            if (isNextTokenSolo) {
                                this_1.currentGroup.hasSoloTests = true;
                                testSuite.hasSoloTests = true;
                                testSuite.isSolo = true;
                            }
                        }
                        else {
                            debug("There is no currentGroup! - ignoring test");
                            this_1.warnings.push("There is no currentGroup! - ignoring test " + currentLocation);
                            return "continue";
                        }
                        isNextTokenSolo = false;
                        isNextTokenIgnore = false;
                        isNextTokenTestCaseParam = false;
                        isNextTokenTest = false;
                    }
                    else if (isNextTokenSetup) {
                        if (!this_1.currentGroup) {
                            testSuite.setupFunctionName = functionName;
                        }
                        else {
                            this_1.currentGroup.setupFunctionName = functionName;
                        }
                        isNextTokenSetup = false;
                    }
                    else if (isNextTokenTearDown) {
                        if (!this_1.currentGroup) {
                            testSuite.tearDownFunctionName = functionName;
                        }
                        else {
                            this_1.currentGroup.tearDownFunctionName = functionName;
                        }
                        isNextTokenTearDown = false;
                    }
                    else if (isNextTokenBeforeEach) {
                        if (!this_1.currentGroup) {
                            testSuite.beforeEachFunctionName = functionName;
                        }
                        else {
                            this_1.currentGroup.beforeEachFunctionName = functionName;
                        }
                        isNextTokenBeforeEach = false;
                    }
                    else if (isNextTokenAfterEach) {
                        if (!this_1.currentGroup) {
                            testSuite.afterEachFunctionName = functionName;
                        }
                        else {
                            this_1.currentGroup.afterEachFunctionName = functionName;
                        }
                        isNextTokenAfterEach = false;
                    }
                    else {
                        debug(" could !get function pointer for " + functionName + " ignoring");
                        this_1.errors.push(" could !get function pointer for " + functionName + (" ignoring: " + currentLocation));
                    }
                }
                else if (isNextTokenSetup) {
                    debug("could not find function directly after '@Setup - ignoring");
                    this_1.warnings.push("could not find function directly after '@Setup - ignoring: " + currentLocation);
                    isNextTokenSetup = false;
                }
                else if (isNextTokenTearDown) {
                    debug("could not find function directly after '@TearDown - ignoring");
                    this_1.warnings.push("could not find function directly after '@TearDown - ignoring: " + currentLocation);
                    isNextTokenTearDown = false;
                }
                else if (isNextTokenBeforeEach) {
                    debug("could not find function directly after '@BeforeEach - ignoring");
                    this_1.warnings.push("could not find function directly after '@BeforeEach - ignoring: " + currentLocation);
                    isNextTokenBeforeEach = false;
                }
                else if (isNextTokenAfterEach) {
                    debug("could not find function directly after '@AfterEach - ignoring");
                    this_1.warnings.push("could not find function directly after '@AfterEach - ignoring: " + currentLocation);
                    isNextTokenAfterEach = false;
                }
                else if (isNextTokenSetup) {
                    debug("could not find setup function - ignoring '@Setup");
                    this_1.warnings.push("could not find setup function - ignoring '@Setup: " + currentLocation);
                    isNextTokenSetup = false;
                }
                else if (isTokenItGroup) {
                    isTokenItGroup = false;
                    isNextTokenSolo = false;
                    isNextTokenIgnore = false;
                }
                nodeTestFileName = "";
                nextName = "";
            }
        };
        var this_1 = this;
        for (var lineNumber = 1; lineNumber <= lines.length; lineNumber++) {
            var state_1 = _loop_1(lineNumber);
            if (state_1 === "break")
                break;
        }
        // exitProcessing:
        this.testCaseOnlyParams = null;
        this.testCaseParams = null;
        this.currentTestCases = null;
        this.hasCurrentTestCase = null;
        if (!isTestSuite) {
            this.warnings.push('no test suite directive for file ' + file.fullPath);
            if (this._isLegacyTestsSupported) {
                debug('legacy tests are supported - checking if this file contains legacy tests');
                testSuite = new TestSuite_1.TestSuite();
                testSuite.filePath = file.pkgPath;
                isTestSuite = this.processLegacyFile(file, testSuite);
            }
        }
        if (!isTestSuite) {
            this.errors.push('Ignoring non test file ' + file.fullPath);
            debug('Ignoring non test file ' + file.fullPath);
        }
        return testSuite;
    };
    TestSuiteBuilder.prototype.getFunctionFromLine = function (line) {
        var matches = line.match(this.functionNameRegex);
        return matches ? matches[2] : null;
    };
    TestSuiteBuilder.prototype.getNumberOfExpectedParamsFromLine = function (line) {
        var matches = line.match(this.functionSignatureRegex);
        var text = matches ? matches[2] : null;
        return text ? text.split(',').length : 0;
    };
    TestSuiteBuilder.prototype.isTag = function (text, tag) {
        return new RegExp("^\\s*" + tag, 'i').test(text);
    };
    TestSuiteBuilder.prototype.getTagText = function (text, tag) {
        var regexp = new RegExp("^\\s*" + tag + "\\s*(.*)", 'i');
        var matches = text.match(regexp);
        return matches && matches.length === 2 ? matches[1] : '';
    };
    TestSuiteBuilder.prototype.reset = function () {
        this.testCaseParams = [];
        this.testCaseParamLines = [];
        this.testCaseOnlyParams = [];
        this.testCaseOnlyParamLines = [];
        this.currentTestCases = [];
        ' we can have multiple test cases based on our para';
        this.hasCurrentTestCase = false;
    };
    TestSuiteBuilder.prototype.addParamsForLine = function (line, tag, lineNumber, targetParamLinesArray, targetParamsArray, currentLocation) {
        var rawParams = this.getTagText(line, tag);
        try {
            var jsonText = rawParams.replace(this.paramsInvalidToNullRegex, '$1$2null');
            var jsonParams = getJsonFromString(jsonText);
            if (jsonParams) {
                targetParamsArray.push(jsonParams);
                targetParamLinesArray.push(lineNumber);
            }
            else {
                this.errors.push("illegal params found at " + currentLocation + ". Not adding test - params were : " + line);
            }
        }
        catch (e) {
            this.errors.push("illegal params found at " + currentLocation + ". Not adding test - params were : " + line);
        }
    };
    TestSuiteBuilder.prototype.processLegacyFile = function (file, testSuite) {
        var code = file ? file.getFileContents() : null;
        this.reset();
        var currentLocation = '';
        var lines = code.split(/\r?\n/);
        var filePath = file.fullPath;
        testSuite.filePath = file.pkgPath;
        this.currentGroup = null;
        this.reset();
        this.currentTestCases = [];
        var testSuiteFunctionNameRegex = new RegExp('^\\s*(function|sub)\\s*testSuite_([0-9a-z\\_]*)\\s*\\(', 'i');
        var testCaseFunctionNameRegex = new RegExp('^\\s*(function|sub)\\s*testCase_([0-9a-z\\_]*)\\s*\\(', 'i');
        var assertInvocationRegex = new RegExp('^.*(m.fail|m.Fail|m.assert|m.Assert)(.*)', 'i');
        var functionEndRegex = new RegExp('^\\s*(end sub|end function)', 'i');
        var testSuiteNameRegex = new RegExp('^\\s*this\\.name\\s*=\\s*"([0-9a-z_]*)"', 'i');
        var setupRegex = new RegExp('^\\s*this\\.setup\\s*=\\s*([a-z_0-9]*)', 'i');
        var teardownRegex = new RegExp('^\\s*this\\.tearDown\\s*=\\s*([a-z_0-9]*)', 'i');
        var addTestregex = new RegExp('^\\s*this\\.addTest\\s*\\(\\s*"([0-9a-z_]*)"\\s*,\\s*([0-9a-z_]*)s*', 'i');
        var isTestSuite = false;
        var isInInitFunction = false;
        var isSolo = false;
        var isIgnore = false;
        var testCaseMap = new Map();
        for (var lineNumber = 1; lineNumber <= lines.length; lineNumber++) {
            currentLocation = filePath + ':' + lineNumber.toString();
            var line = lines[lineNumber - 1];
            // debug(line);
            if (lineNumber > this._maxLinesWithoutSuiteDirective && !isTestSuite) {
                debug('IGNORING FILE WITH NO LEGACY TESTS AVAILABLE : ' + currentLocation);
                this.warnings.push('Ignoring file with no legacy tests' + file.fullPath);
                break;
            }
            if (line.match(testSuiteFunctionNameRegex)) {
                isTestSuite = true;
                isInInitFunction = true;
                testSuite.isLegacy = true;
                testSuite.isValid = true;
                if (isIgnore) {
                    testSuite.isIgnored = true;
                }
                if (isSolo) {
                    testSuite.isSolo = true;
                }
                continue;
            }
            else if (this.isTag(line, Tag_1.Tag.SOLO)) {
                isSolo = true;
                continue;
            }
            else if (this.isTag(line, Tag_1.Tag.IGNORE)) {
                isIgnore = true;
                continue;
            }
            else if (line.match(setupRegex)) {
                var match = line.match(setupRegex);
                testSuite.setupFunctionName = match[1];
            }
            else if (line.match(teardownRegex)) {
                var match = line.match(teardownRegex);
                testSuite.tearDownFunctionName = match[1];
            }
            else if (line.match(functionEndRegex)) {
                if (isInInitFunction) {
                    this.currentGroup = new ItGroup_1.ItGroup('LEGACY TESTS', false, false, file.normalizedFileName);
                    this.currentGroup.file = file;
                    this.currentGroup.setupFunctionName = testSuite.setupFunctionName;
                    this.currentGroup.isLegacy = true;
                    testSuite.itGroups.push(this.currentGroup);
                    isInInitFunction = false;
                    isIgnore = false;
                    isSolo = false;
                }
            }
            else if (line.match(testSuiteNameRegex)) {
                testSuite.name = line.match(testSuiteNameRegex)[1];
            }
            else if (line.match(addTestregex)) {
                if (!isInInitFunction) {
                    debug('Found addTestCase, when not in a legacy test suite init function. Ignoring');
                    continue;
                }
                var match = line.match(addTestregex);
                var testCaseName = match[1];
                var testCaseFunctionName = match[2];
                if (testCaseName !== '' && testCaseFunctionName !== '') {
                    testCaseMap[testCaseFunctionName.toLowerCase()] = testCaseName;
                }
                else {
                    debug(' found badly formed addTestCase function call in test suite init function. Ignoring');
                }
                continue;
            }
            else if (line.match(testCaseFunctionNameRegex)) {
                var functionName = line.match(testCaseFunctionNameRegex)[2];
                functionName = 'testcase_' + functionName.toLowerCase();
                if (!functionName) {
                    debug('found badly formed test function name. Ignoring');
                    isIgnore = false;
                    isSolo = false;
                    continue;
                }
                var testName = testCaseMap[functionName];
                if (!testName) {
                    debug('Encountered test function ' + functionName + 'but found no matching AddTestCase invocation');
                    isIgnore = false;
                    isSolo = false;
                    continue;
                }
                var testCase = new TestCase_1.TestCase(testName, functionName, isSolo, isIgnore, lineNumber);
                if (isIgnore) {
                    testSuite.hasIgnoredTests = true;
                }
                this.currentTestCases = [testCase];
                this.currentGroup.addTestCase(testCase);
                if (isSolo) {
                    // debug('>>> ' + aTestCase.name + ' IS SOLO!');
                    this.currentGroup.hasSoloTests = true;
                    testSuite.hasSoloTests = true;
                    testSuite.isSolo = true;
                }
                isIgnore = false;
                isSolo = false;
                continue;
            }
            else if (line.match(assertInvocationRegex)) {
                if (this.currentTestCases.length === 0) {
                    this.errors.push("Found assert before test case was declared! " + currentLocation);
                }
                else {
                    this.currentTestCases[0].addAssertLine(lineNumber);
                }
            }
        }
        return isTestSuite;
    };
    return TestSuiteBuilder;
}());
exports.TestSuiteBuilder = TestSuiteBuilder;
